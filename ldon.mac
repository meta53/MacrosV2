|**
----------------------------
LDON_GENERIC.mac updated version 01.19.2022
----------------------------
This macro will request an zone start based LDON, accept it, and enter it
Proceed to complete it, and exit. Re-request.
Note: will load/unload other group members macros on enter/exit.
Note: will run through lobby and request lobby buffs (EQTitan specific)

Requries ACTIVE HACKS (mq2piggyzone & mq2mmoreachit)
    
Usage: /mac ldon bcga
______________________________________________
REVISION HISTORY
    09.24.2017	xiris	INITIAL REVISION
	09.26.2017  xiris   MODIFIED to use an ini to define all mission criteria based on starting zone (butcher,everfrost,etc)
	09.30.2017  xiris   Random code clean up
	06.18.2020	xiris   Commented and cleaned up. Again.
	12.08.2021	xiris	Aligned the puller part of the macro with bot_pull updates using MQ2Nav
	12.27.2021	xiris	Changed completion routine to use Origin to go back to lobby instead of dealing with shitty trying to get to zone out
	01.19.2022	xiris	Added support for mq2doors due to takish-hiz having retarded door mechanics
						Added support to stop and ask for buffs in lobby since we run through anyway
	03.04.2022  xiris   Added support for MQ2AdvPath pathing for NRO as test for turning off mq2nav after lobby magus
						to NRO zone in.
	03.06.22	xiris	Added support for high requesting high risk missions (bln_highRisk)					
______________________________________________
REQUIRED PLUGINS
    mq2cast
    mq2eqbc
    mq2debuffs
	mq2doors
    mq2moveutils
	mq2nav
	mq2piggyzone
	mq2mmoreachit
______________________
REQUIRED INCLUDES 
	xiris_common/spell_routines.inc
	xiris_common/xiris_common.inc
**|


#include xiris_common/xiris_common.inc

#Turbo 40

#define INI_ldonInfo xiris_common/xiris_ldon_definitions.ini

#EVENT RageOff              "#*#is no longer enraged#*#"
#EVENT RageOn               "#*#has become ENRAGED#*#"
#EVENT Zoned                "You have entered#*#"
#EVENT Zoned                "LOADING, PLEASE WAIT..."
#EVENT EndMac				"#*#monkeybutter#*#"
#EVENT NoLOS				"#*#you cannot see your target#*#"
#EVENT TooClose				"#*#your target is too close#*#"
#EVENT MoveFail				"#*#Could not find path to destination#*#"


Sub Main(string _channel, string _announce, bool _useDownFlags, bool _highRisk)
	/delay 5

	|-- initialize common xbot variables
	/call xbot_initialize ${Me.Name}
	
	|-- initialize variables specific to this macro
	/call variant_initialize  ${_channel} ${_announce} ${_useDownFlags} ${_highRisk}
	
	|-- report status
	/delay 10
	/echo LDON Runner >> @${_channel}  >> Theme: ${Zone.ShortName}


	|-- Build Alert List
	/call setAlerts

	|-- remove yourself from any adventures that might be lingering
	/echo Killing any previous LDON adventure that is active
	/squelch /bcga //notify AdventureRequestWnd AdvRqst_RequestButton leftmouseup
	/delay 2s
	/squelch /bcga //notify ConfirmationDialogbox CD_Yes_Button leftmouseup
	|**
	 ----------------------------
	 Setup Loop
	 ----------------------------
	 Set up the current LDON based on the start zone shortName.
	 butcher|everfrost|nro|sro|ecommons
	 ----------------------------
	**|
	:SetupLoop
		/echo Main:SetupLoop

		|-- Enable MQ2Nav if we are *NOT* doing the NRO theme;
		/if (${zoneRequest.Equal[nro]}) {
			/echo In NRO killing mq2nav
			/call LoadPlugin mq2nav FALSE
		} else {
			/echo not in NRO starting mq2nav
			/call LoadPlugin mq2nav TRUE
		}
		

		|-- check that the group is in zone
		/call chkGroup

		|-- request the LDON, kicking off the zoning to start logic
		|   this will move entire group into LDON instance
		|   requestLDON-> zoneLDON -> setupTask
		/call requestLDON

		| double check that I have one cause this fucks up now and then on this server
		/if (${Window[AdventureRequestWnd].Child[AdvRqst_NPCText].Text.Find[You are not currently assigned]}) {
			/goto :SetupLoop
		}
		/if (${haveMission}) /call zoneLDON
		/doevents
		/if (!${inMission} || !${haveMission}) /goto :SetupLoop

	|**
	 ----------------------------
	 Mission Loop
	 ----------------------------
	 Checks Completion
	 Runs the bot_pull.mac functionality
	 ----------------------------
	**|
	
	:MissionStart	
	/echo Main:MissionStart
	|-- set up any melee buffs/delay and then go to camp inside the LDON zone;
	/call chkGroup
	/delay 5s
	/varset int_currentCamp 1
	/call moveCamp ${int_currentCamp}
	
	:MissionLoop
		/echo Main:MissionLoop
		/if (${MacroQuest.GameState.Equal[CHARSELECT]} || ${MacroQuest.GameState.Equal[PRECHARSELECT]} ) /end
		/if (${Me.Casting.ID} && ${Me.Hovering}||${Window[tradewnd].Open}||${Window[lootwnd].Open}) /goto :mainLoop
		
		/doevents
		
		|-- utility checking
		/call chkUtils
		/call chkDownshits
		
		|-- reset variables, and make sure I am in the zone still and in mission
		/call setRSTVars
		/call chkZone
		/if (${Macro.Return.Equal[LOBBY]}) {
			/dgt We seem to have gotten fucked up and are now in the lobby at ${Time.Time24}
			/dgt Resetting everything and going again
			/call OriginToLobby
			/call ResetAtLobby
			/delay 10s
			/call chkGroup
			/goto :SetupLoop
		}
		|-- check to see if I've finished the mission yet
		/if (!${inMission} || !${haveMission})  /goto :SetupLoop
		/if (${SpawnCount[NPC radius 100]} == 0 && ${Zone.ShortName.NotEqual[${zoneRequest}]}) /call chkLDONCompletion	
		/if (${Zone.ShortName.Equal[${zoneRequest}]}) /goto :SetupLoop
		
		|-- reset group to camp spot (leash) if its empty
		/if (${SpawnCount[npc radius ${int_campRadius} zradius 25]} == 0) {
			/call resetCamp
			/docommand /${cmdChannel} RefreshXTarget
		}
		
		|-- target hunter
		/call getTarget
		/if (${Target.Distance} > 20) /call pullTarget
		/call killTarget
		
		|-- am I still in mission?
		/if (${inMission}) /goto :MissionLoop

	
	|-- adventure is over, start the setup of another, ad infinitem!
	/goto :SetupLoop

/return


Sub requestLDON
	/if (${inMission}) /return
	/if (${haveMission}) /return
	/echo requestLDON in zone ${zoneRequest} currently in: ${Zone.ShortName}
	|-- this is anachronistic if we are phasing out piggyzone
	/if (${Zone.ShortName.NotEqual[${zoneRequest}]}) {
		/echo Not in ${zoneRequest}, heading there now. Delaying 45s.
		/zone ${zoneRequest}
		/delay 45s
	}
	
	/declare requestCount int local 1
	
	|-- Get Adventure Loop, request the adventure from the giver.
	:GetAdventure
		/echo Getting adventure from ${adventureGiver} ${Time.Time24}
		/call TrueTarget ${Spawn[NPC ${adventureGiver}].ID}
		
		/if (${zoneRequest.NotEqual[nro]}) {
			/navigate target
			/goto :GetAdventureNavLoop
		} else {
			/stick
			/delay 5s
			/stick off
			/goto :GetAdventureClick
		}
		
		:GetAdventureNavLoop
			/if (${Navigation.Active}) {
				/delay 10
				/goto :GetAdventureNavLoop
			} 


		:GetAdventureClick
		/face fast
		/click right target
		/delay 2s

	|-- set the difficulty to Hard (defaulted to no)
	/if (${bln_highRisk}) {
		/echo Requesting a High Risk Mission
		/notify AdventureRequestWnd AdvRqst_RiskCombobox listselect ${Window[AdventureRequestWnd].Child[AdvRqst_RiskCombobox].List[High]}
	} 

	|-- set the type to Kill examples: Note EqTitan code fix as of 1/1/22 allows for chain requesting missions
	|   The only mission that will be required is the mob count since its the default.
	|  ${Window[AdventureRequestWnd].Child[AdvRqst_typeCombobox].List[Single Boss]}
	|  ${Window[AdventureRequestWnd].Child[AdvRqst_typeCombobox].List[Mob count]}


	/delay 10
		
	/varset ldonType NOAVAIL
	|-- First choice: Mob Count, see if this mission is available
	/if (${Window[AdventureRequestWnd].Child[AdvRqst_typeCombobox].List[Mob count]} > 0) {
		/notify AdventureRequestWnd AdvRqst_typeCombobox listselect ${Window[AdventureRequestWnd].Child[AdvRqst_typeCombobox].List[Mob count]} 
		/delay 10
		/notify AdventureRequestWnd AdvRqst_RequestButton leftmouseup
		/delay 2s
		/if (${Window[AdventureRequestWnd].Child[AdvRqst_NPCText].Text.Find[The number of adventures returned was zero]}) {
			/echo Adventure type: "Mob Count" unavailable.
		} else {
			/echo Adventure type: "Mob Count" accepted.
			/varset ldonType Mob count
			/goto :Accept
		}
	}
	
	/if (${zoneRequest.Equal[sro]}) {
		/echo GUK LDON can only do the kill count, since GukA for boss mob is un-navigable
		/goto :TryAgain
	}
	
	|-- have to close window and try again now apparently. 
	:GetAdventure2
		/keypress esc
		/keypress esc
		/keypress esc
		
		/echo Getting adventure2 from ${adventureGiver} ${Time.Time24}
		/call TrueTarget ${Spawn[NPC ${adventureGiver}].ID}
		/face fast
		/click right target
		/delay 2s
	
	|-- Second choice: Single Boss, see if this mission is available
	/if (${Window[AdventureRequestWnd].Child[AdvRqst_typeCombobox].List[Single Boss]} > 0) {
		/notify AdventureRequestWnd AdvRqst_typeCombobox listselect ${Window[AdventureRequestWnd].Child[AdvRqst_typeCombobox].List[Single Boss]} 
		/delay 10
		/notify AdventureRequestWnd AdvRqst_RequestButton leftmouseup
		/delay 2s
		/if (${Window[AdventureRequestWnd].Child[AdvRqst_NPCText].Text.Find[The number of adventures returned was zero]}) {
			/echo Adventure type: "Single Boss" unavailable.
		} else {
			/echo Adventure type: "Single Boss" accepted.
			/varset ldonType Single Boss
			/goto :Accept
		}
	}
	/delay 2s


	
	/echo ldonType: ${ldonType}
	|-- No satisfactory type is available, go back to :GetAdventure
	/if (${ldonType.Equal[NOAVAIL]} || ${Window[AdventureRequestWnd].Child[AdvRqst_NPCText].Text.Find[You are not currently assigned]}) {
		:TryAgain
		/echo (${requestCount}) No satisafactory Adventure type available, delaying for 1m. ${Time.Time24}
		/delay 1m
		/varcalc requestCount ${requestCount}+1
		/goto :GetAdventure
	}
	
	|-- Found one, Accept the mission and start the zoning loop.
	:Accept
		/delay 10
		|-- Set the variables that define which zone we are headed to.
		/call setEntranceVars
		
		|-- Accept the task
		/notify AdventureRequestWnd AdvRqst_AcceptButton leftmouseup
		/varset haveMission TRUE
		/delay 3s
/return

Sub setEntranceVars

	|-- determine the entrance for the mission you received
	/if (${Window[AdventureRequestWnd].Child[AdvRqst_NPCText].Text.Find[unearthed grave in Lesser Faydark]}) /varset ldonEntrance unearthed_grave
	/if (${Window[AdventureRequestWnd].Child[AdvRqst_NPCText].Text.Find[crypt in Lesser Faydark]}) /varset ldonEntrance crypt
	/if (${Window[AdventureRequestWnd].Child[AdvRqst_NPCText].Text.Find[glimmering portal]}) /varset ldonEntrance glimmering
	/if (${Window[AdventureRequestWnd].Child[AdvRqst_NPCText].Text.Find[snowy mine]}) /varset ldonEntrance snowy_mine
	/if (${Window[AdventureRequestWnd].Child[AdvRqst_NPCText].Text.Find[quicksand pit]}) /varset ldonEntrance quicksand_pit
	/if (${Window[AdventureRequestWnd].Child[AdvRqst_NPCText].Text.Find[through a cave in Southern Ro]}) /varset ldonEntrance sro_cave
	/if (${Window[AdventureRequestWnd].Child[AdvRqst_NPCText].Text.Find[through a barricaded door in Upper Guk]}) /varset ldonEntrance barricaded_door
	/if (${Window[AdventureRequestWnd].Child[AdvRqst_NPCText].Text.Find[through a rotting tree trunk in Innothule]}) /varset ldonEntrance rotting_tree
	
	/echo setting ${ldonEntrance} 
	
	|-- pull information determined by entrance from INI file (waypoint, doortarget and starting zone)
	/varset wpIN  ${Ini[INI_ldonInfo,${ldonEntrance},wpIN]}
	/varset dtIN  ${Ini[INI_ldonInfo,${ldonEntrance},dtIN]}
	/varset zoneStart ${Ini[INI_ldonInfo,${ldonEntrance},zoneStart]}
	/echo setting ${ldonEntrance} entrance vars --> ${zoneStart} ${wpIN} ${dtIN}
	

/return


|**
 ----------------------------
 zoneLDON
 ----------------------------
 Zones everyone to the LDON start zone, and once in the start zone
 runs everyone to the LDON zone entrance, and clicks the door
 ----------------------------
**|
Sub zoneLDON
	/declare waitForZoneStart 	int local 0
	/declare waitForDoorStart	int	local 0
	/declare waitForAllInLDON 	int local 0
	/declare missingCount		int local 0	
	/declare i int local 0
	| Mistmoore requires zoning to ${zoneStart}
	/echo zoneLDON: headed to ${ldonEntrance} in ${zoneStart} in 1s
	/delay 10
	
	|-- loop through group and /dt them to zone (bcga doesnt work for out of zone group - its likely a bug)
	|-- logic change 12.13 to better handle same zone starts (everfrost, nro);

	/if (${zoneStart.Equal[${zoneRequest}]}) {
		|-- start of LDON is same zone as requesting the LDON, go directly to entrance
		/goto :NavToLDON_ZoneEntrance
	} else {
		|-- commonlands requires you to zone into sro, its easier to call a magus to boot you there
		/if (${zoneRequest.Equal[ecommons]}) {
			/call zoneByMagus "South Ro"
		} else {
			/docommand /${cmdChannel} //zone ${zoneStart}
		}
	}
	
	/delay 10s
	
	:navToLDON_MagusWaitLoop
	/delay 10
	/if (${Group.AnyoneMissing}) /goto :navToLDON_MagusWaitLoop
	

	|--piggy loop, basically wait until in the starting zone
	:navToLDON_ZoneStartLoop
		/varcalc waitForZoneStart ${waitForZoneStart} + 1
		/echo waitForZoneStart ${waitForZoneStart}

		/if (${Zone.ShortName.NotEqual[${zoneStart}]}) {
			/delay 10s
			/goto :navToLDON_ZoneStartLoop
		}
		/call chkGroup
		/if (${waitForZoneStart} > 10) /call killMacro "Group failed to arrive at ${zoneStart} ${waitForZoneStart}"
		/if (${Group.AnyoneMissing})   /goto :navToLDON_ZoneStartLoop
	
	|-- navigate to zone in;
	:NavToLDON_ZoneEntrance
	/echo All in ${zoneStart}, going to the ${ldonEntrance}
	
	|-- note SRO (upper guk) you can't navigate to the zone in. You will fall off ledges.
	/if (${zoneRequest.Equal[sro]}) {
		/echo GUK LDON Barricaded Door Entrance can only be reached via /switch since group cannot NAV there
		/goto :ZoneIntoLDONInstance
	} else /if (${zoneRequest.Equal[ecommons]}) {
		|-- SRO (rujark) you will get stuck on a fucking tent, 
		| so have a waypoint to move you away from tents before ehading to wp in
		/echo SRO_CAVE is problematic to get to, trees get you stuck. Fuckit, use /switch
		/goto :ZoneIntoLDONInstance
	} else /if (${zoneRequest.Equal[nro]}) {
		| North Ro is crashing with mq2nav, use insta click like SRO
		/echo NRO_PIT is problematic to get to mq2nav breaks the zone. Fuckit, use /switch
		/goto :ZoneIntoLDONInstance
	}  else {
		| Fuck using Nav in the request zones, it just crashes the shit out of us
		/echo Fuckit, using switch
		/goto :ZoneIntoLDONInstance

	}
	|}else {
	|	/docommand /${cmdChannel} //nav wp ${wpIN}
	|	/delay 5s
	|}

	:NavToLDON_ZoneEntranceLoop
		/if (${Navigation.Active}) {
			/delay 2s
			/goto :NavToLDON_ZoneEntranceLoop
		} 
	/delay 10s
	|-- wait for the group members to be at the same point	
	|-- this is problematic, but I can't think of a better way except just bypassing with switch
	|-- fuck it. just switch
	:NavToLDON_ZoneEntranceWait
		/varcalc waitForDoorStart ${waitForDoorStart} + 1
		/varset missingCount 0
		/echo NavToLDON_ZoneEntranceWait (checking group members ready to zone in)
		/for i 1 to 5 
			/echo  ${Group.Member[${i}]} ${Group.Member[${i}].Distance}
			/if (${Group.Member[${i}].Distance}  > 25) {
				/echo  ${Group.Member[${i}]} ${Group.Member[${i}].Distance} isn't close yet, telling them to target me and hurry their asses up.
				/squelch /dt ${Group.Member[${i}]} //tar ${Me.Name}
				/squelch /dt ${Group.Member[${i}]} //nav target
				/varcalc missingCount ${missingCount} + 1
				/delay 1s
			}
		/next i
	
		|/if (${waitForDoorStart} > 12) /call killMacro "Group failed to zone into at ${wpIN}"
		|-- someone probably got stuck on a fucking tree, just force it.
		/if (${waitForDoorStart} > 12) /goto :ZoneIntoLDONInstance
		/if (${missingCount} > 0) {
			/echo waiting for ${missingCount}, waiting 10s
			/delay 10s
			/goto :NavToLDON_ZoneEntranceWait
		}
	/delay 1s

	
	|-- tell everyone to switch the door
	:ZoneIntoLDONInstance
	/call chkGroup
	/echo Everyone At the ${zoneStart} and at ${ldonEntrance} ${Time.Time24}
	/dgt Everyone At the ${zoneStart} and at ${ldonEntrance} ${Time.Time24}
	/echo All ready, Zone in
	/delay 10
	/docommand /${cmdChannel} //switch ${dtIN}
	/delay 10s

	|-- loop to wait for everyone to zone in
	:ZoneIntoLDONInstanceWait
		/varcalc waitForAllInLDON ${waitForAllInLDON}+1
		/echo Waiting for all to zone into LDON
		/delay 10s

		/if (${waitForAllInLDON} > 12) /call killMacro "Group failed to zone into at ${wpIN}"
		/if (${Group.AnyoneMissing})  /goto :ZoneIntoLDONInstanceWait 
		

	
	|-- Setup the task with INI Data
	/varset inMission TRUE	
	/echo DONE with zoneLDON
	/call setupTask
/return

Sub killMacro(reason)
	/echo Something failed [${reason}] at ${Time.Time24}
	/bcga //end
/return

|**
 ----------------------------
 setupTask
 ----------------------------
 Sets up the mission parameters once inside the LDON mission zone
 ----------------------------
**|

Sub setupTask
	/echo setupTask inMission:${inMission} haveMission:${haveMission} ${Zone.ShortName}
	
	/varset zoneMission ${Zone.ShortName}
	/echo setupTask ${zoneMission} ${inMission} ${haveMission}
	
	|-- pulling zone data from INI
	/varset dtOUT 			${Ini[INI_ldonInfo,${zoneMission},dtOUT]}
	/varset killTarget 		${Ini[INI_ldonInfo,${zoneMission},killTarget,NULL]}
	/varset int_campCount	${Ini[INI_ldonInfo,${zoneMission},campCount,6]}
	/varset int_maxRadius	${Ini[INI_ldonInfo,${zoneMission},pullDist,350]}
	/varset int_xOUT		${Ini[INI_ldonInfo,${zoneMission},xOUT,0]}
	/varset int_yOUT		${Ini[INI_ldonInfo,${zoneMission},yOUT,0]}
	/varset int_zOUT		${Ini[INI_ldonInfo,${zoneMission},zOUT,${Me.Z}]}
	|-- If we are killboss type mission we need to add killboss to list 2
	/if (${killTarget.NotEqual[NULL]}) /squelch /alert add 2 npc ${killTarget}
	
	/echo ------------
	/echo setting ${zoneMission} zone vars:
	/echo 	dtOUT: ${dtOUT}, killTarget: ${killTarget}, int_campCount ${int_campCount}
	/echo 	int_maxRadius: ${int_maxRadius}, int_xOUT: ${int_xOUT}, int_yOUT: ${int_yOUT}, int_zOUT: ${int_zOUT}
	/echo ------------
	/delay 10
	|-- Turn off the fucking doors
	/bcga //toggledoors on
	
	|-- Tell the group to turn on MQ2Nav
	/call LoadPlugin mq2nav TRUE

	|-- Tell rest of group to load their normal macroset;
	/echo In ${Zone.Name}, setting up bot_loader and delaying 5s
	/bcg //mac bot_loader ${Me.Name} 0 70 NULL 0
	/delay 5s
	|-- set up group variables, change here based on group makeup;
	/call setGroupCommands
	/echo DONE with setupTask
	
/return


Sub zoneByMagus(_string zoneToRequest) 
	/g Using Magus to zone ${zoneToRequest}
	/docommand /${cmdChannel}  //tar npc magus
	/delay 10
	/docommand /${cmdChannel}  //nav target
	:magusNavWait
	/delay 10
	/if (${Nav.Active}) /goto :magusNavWait

	|-- Disable MQ2Nav
	/call LoadPlugin mq2nav FALSE

	/delay 5s
	|-- open up the magus's merchant window which fixes the rando desynch
	/docommand /${cmdChannel} //click right target
	/delay 10
	/docommand /${cmdChannel} //keypress esc
	/delay 10
	/docommand /${cmdChannel} //tar npc magus
	/delay 10
	/docommand /${cmdChannel} //say ${zoneToRequest}
	/delay 45s
	|-- Enable MQ2Nav
	/call LoadPlugin mq2nav TRUE
/return 

Sub RequestLobbyBuffs
	/g Requesting Lobby Buffs

	/delay 10
	/bcga //plugin mq2nav
	
	|-- Phanti Buffs
	:phanti_tar
		/bcga //tar npc phanti
		/bcga //nav target
	:phanti_run
		/delay 20
		/if (${Navigation.Active}) /goto :phanti_run
	:phanti_ask
		/delay 20
		/bcga //say haste
		/delay 10
		/bcga //say kei
		/delay 20
	
	|-- Firiona Vie Buffs
	:firi_tar
		/bcga //tar npc firi
		/bcga //nav target
	:firi_run
		/delay 20
		/if (${Navigation.Active}) /goto :firi_run
	:firi_ask
		/delay 20
		/bcga //say virtue
		/delay 20

	|-- Fuzzy Buffs
	:fuzzy_tar
		/bcga //tar npc fuzzy
		/bcga //nav target
	:fuzzy_run
		/delay 20
		/if (${Navigation.Active}) /goto :fuzzy_run
	:fuzzy_ask
		/delay 20
		/bcga //say ds
		/delay 10
		/bcga //say regen
		/delay 20
	
	|-- Run to Magus
	:magus_tar
		/bcga //tar npc magus
		/bcga //nav target
	:magus_run
		/delay 20
		/if (${Navigation.Active}) /goto :magus_run
	
/return

Sub chkZone
	/if (${Zone.ShortName.NotEqual[${SZ_shortName}]}) {
		/if (${Zone.ShortName.Equal[${Me.BoundLocation[0]}]}) {
			/docommand /${cmdChannel}  I died! GTFO! ${Time.Time24}
			/delay 5s
			/return LOBBY
		}
	}
/return

Sub OriginToLobby
	/declare originAttempt int local 0
	/declare i int local 1
	
	:OriginDelay
	/if (${AltAbilityTimer[Origin]} == 0) {
		/if (${Zone.ShortName.NotEqual[${Me.BoundLocation[0]}]}) {
			/varcalc originAttempt ${originAttempt} + 1
			|-- tell each group member that isn't a bard to cast origin, bard add origin to queue
			/for i 0 to ${Group}
				/if (${Group.Member[${i}].Class.ShortName.Equal[BRD]}) 	  /dt ${Group.Member[${i}]} //medley queue origin
				/if (${Group.Member[${i}].Class.ShortName.NotEqual[BRD]}) /dt ${Group.Member[${i}]} //casting "Origin" alt
			/next i

			/delay 40s
			/return
		} else {
			/return
		}
	} else {
		/echo Origin not Ready, delaying 1m  ${Time.Time24}
		/delay 1m
		/goto :OriginDelay
	}

/return 

Sub ResetAtLobby
	/if (${Zone.ShortName.Equal[${Me.BoundLocation[0]}]}) {
		/call RequestLobbyBuffs
		/call zoneByMagus ${zoneMagus}
	} else {
		/g Not at lobby, can't reset here, something went wrong at ${Time.Time24}
		/return
	}
/return

Sub setCamp
	/echo Setting camp at camp${int_currentCamp} out of ${int_campCount}
	/waypoint add camp${int_currentCamp} 
	/if (${Plugin[mq2nav].Name.Length}) /navigate RecordWaypoint bot_pull_nav
	/varset int_campX ${Me.X}
	/varset int_campY ${Me.Y}
	/varset int_campZ ${Me.Z}
	/delay 1s
/return

|-- Moves the current camp to n+1
|   If we cannot navigate (probably in a wall or geometry)
|   We will warp back to the current camp and then continue.
Sub moveCamp(int _campNumber) 
	/declare prevCamp int local 1
	/varcalc prevCamp ${_campNumber}-1
	/echo Moving to Camp ${_campNumber}
	/bcg //mqpause on
	/docommand /${cmdChannel} //nav wp camp${_campNumber}
	/delay 10
	/doevents MoveFail 
	/if (${bln_moveFail}) {
		/varset bln_moveFail FALSE
		/docommand /${cmdChannel} //warp wp camp${prevCamp}
		/delay 10
		/docommand /${cmdChannel} //nav wp camp${_campNumber}
	} 
	:moveCampNavLoop
		/echo Moving to Camp ${_campNumber}
		/if (${Navigation.Active}) {
			/delay 2s
			/goto :moveCampNavLoop
		} 
	/bcg //mqpause off
	/call setCamp
/return

Sub Event_MoveFail
	/varset bln_moveFail TRUE 
	/doevents flush MoveFail
/return 


Sub setRSTVars
	/varset	bln_validTGT	FALSE
	/varset bln_TGTDead		TRUE
	/varset bln_TGTLocal	FALSE
	/alert clear 3
	/target clear
/return

Sub setTGTAlert
	/echo setTGTAlert ${Target.ID} ${Target.Name}
	/alert add 3 id ${Target.ID}
	/keypress esc
/return


|**
 ----------------------------
 getTarget
 ----------------------------
 Checks to see if there are any mobs within camp, if so, it targets them indiscriminately
 otherwise, it attempts to target a NPC that does not fall in the alert list
 Calls chkTargetValid once a target has been found, if that returns as valid, it continues
 ----------------------------
**|
Sub getTarget
	/echo getTarget
	/if (${Me.Sitting}) /sit off
	/if (${Zone.ShortName.Equal[${zoneRequest}]}) /return
	:acquireLoop
		/call setRSTVars
		/squelch /target clear
		/call chkLDONCompletion
		|----------USE THIS FOR HUNTER (ALERT 2) and IGNORE ALERT 1, 3 --------
		/if (${SpawnCount[npc radius ${int_campRadius} zradius 25]} > 0) {
			/echo NPC in camp, killing
			/target npc range ${int_minTLevel} ${int_maxTLevel} radius ${int_maxRadius} noalert 1
			/delay 5
		} else /if (${SpawnCount[npc alert 2 radius ${int_alert2Radius} range ${int_minTLevel} ${int_maxTLevel}]} > 0) {
			/echo NPC on alert 2 is up, killing
			/target npc alert 2
			/delay 5
		} else /if (${SpawnCount[npc alert 2 radius ${int_alert2Radius} range ${int_minTLevel} ${int_maxTLevel}]} == 0 && ${SpawnCount[npc noalert 1]} > 0) {
			/echo No NPCs on the alert 2 list are up, trying random NPC
			/target npc range ${int_minTLevel} ${int_maxTLevel} radius ${int_maxRadius} noalert 1 
			/delay 5
		} else {
			/echo no NPCs around, delaying 1m
			/delay 1m
			/goto :AcquireLoop
		}
		
		/if (${Target.ID} && (${Target.Distance} <= ${int_campRadius})) {
			|--if it is close, its valid;
			/varset bln_validTGT	TRUE
		} else {
			|--check the target
			/if (${Target.ID}) /call chkTargetValid
		}
		
		
		|--restart
		/if (!${bln_validTGT}) {
			|-- if there is more than 1 camp in our dataset, we can start walking through the camps
			/if (${int_campCount} > 1) {
					/echo Checking on moving the camp
					:MoveCamp
					/if (${int_currentCamp} < ${int_campCount}) {
						/varcalc int_currentCamp ${int_currentCamp} + 1
					} else {
						/varcalc int_currentCamp ${int_currentCamp} - 1
					}
					
					/echo Moving Camp to ${int_currentCamp}
					/call moveCamp ${int_currentCamp}
					/delay 10
			} else {
				/echo no valid target delaying 5s
				/delay 5s
			}
			/goto :acquireLoop
		}
		|--target is valid, continue
		
		/varset int_targetID ${Target.ID}
		/varset bln_TGTDead		FALSE
		/varset int_distTGT ${Int[${Target.Distance}]}
		/echo Acquired ${Target.Name} at range ${Int[${Target.Distance}]} killed: (${int_killCount})
/return

|**
 ----------------------------
 chkTargetValid
 ----------------------------
 Checks to see if the current target passes the criteria
 If it is a valid target, bln_validTGT is assigned TRUE
 Returns to getTarget
 ----------------------------
**|
Sub chkTargetValid
	/echo chkTargetValid ${Target.Name}
	/if (${Target.Type.NotEqual[NPC]}) /return
	
	|--check if there is a path to the target
	/if (!${Navigation.PathExists[target]}) {
		/echo INVALID No Path to Target
		/call setTGTAlert
		/return
	}
	
	|--check my target is the apropriate level
	/if ((${Target.ID}) && (${Target.Level} < ${int_minTLevel})) {
		/echo target too low of a level
		/call setTGTAlert
		/return
	}
	/if (${Target.Underwater}) {
		/echo target is underwater
		/call setTGTAlert
		/return
	}
	
	|--check my target is the above the apropriate z-radius floor
	/if ((${Target.ID}) && ${Int[${Target.Z}]}<${int_minZHeight}) { 
		/echo target below z floor
		/call setTGTAlert
		/return
	} 
	|--check my target is the above the apropriate z-radius ceiling
	/if ((${Target.ID}) &&${Int[${Target.Z}]}>${int_maxZHeight}) { 
		/echo target below z ceiling
		/call setTGTAlert
		/return
	}
	
	/varset bln_validTGT	TRUE
/return 	




|**
 ----------------------------
 pullTarget
 ----------------------------
 Checks to see if we need to pull target, if so, then we initiate the pulling mechanism
 and then once aggro is established, drags the mob back to camp to be killed
 Calls AggroTarget
 Calls makecamp return
 Returns to mainLoop if a valid pull has been achieved
 ----------------------------
**|
Sub pullTarget
	/echo pullTarget
	/declare campDist int local
	|--check to see if we have a valid target, or skip
	/declare attempt int local 0
	

	
	:pullLoop
		/if (!${bln_validTGT}) 				/goto :return
		/if (!${Target.ID}) 				/goto :return
		/if (${Target.Type.NotEqual[NPC]}) 	/goto :return
	
		|-- start navigating if you havent
		/if (!${Navigation.Active}) /navigate target
		
		|-- check to see if I have aggro
		/if (${Me.TargetOfTarget.CleanName.Equal[${Me.CleanName}]} || ${Me.XTarget[1].ID} > 0) {
			/echo I have aggro.
			:returnStart
				/echo Returning to camp.
				/navigate waypoint bot_pull_nav
			:returnLoop
				/delay 1s
				/if (${Navigation.Active}) /goto :returnLoop
				/goto :return
		} else {
			|/echo I do not have aggro
			|-- am I close enough to aggro?
			/if (${Target.Distance} < ${int_castDistance} && ${Target.LineOfSight}) {
				|/echo Calling aggro loop because dist is within castDist range
				/goto :aggroLoop
			}
			
		}
		/goto :pullLoop
		
	:aggroLoop
		/navigate stop
		/face fast
		/if (!${Target.ID}) 		  /goto :return
		/if (${Me.TargetOfTarget.ID}) /goto :return
		/if (!${Target.LineOfSight})  /goto :pullLoop

		
		|--attempt to aggro the mob
		/if (${strPullType.Equal[RANGED]}) {
			/ranged
		} else {
			/echo ${Me.SpellReady[${spell_hate}]} Cast "${spell_pull}" ${spell_pullGem} 5s
			/call MQ2Cast "${spell_pull}" ${spell_pullGem}
		}
		/delay 5
		/doevents NoLOS
		/doevents TooClose
		/delay 5
		|-- Sometimes if we aren't spell casting and using range weapons we might be too close, and cannot hit them with it.
		/if (${bln_tooClose}) {
			/echo Too Close! Handling
			/doability Bellow
			/delay 1s
			/doability Taunt
			/varset bln_tooClose FALSE
		}
		
		|-- Target.LineOfSight gets a little wonky sometimes with floor items (boxes, etc) in the way
		/if (${bln_noLOS}) {
			/echo NoLOS! Handling
			/navigate target
			/delay 2s
			/varset bln_noLOS FALSE
		}
		/goto :pullLoop	
		
	:return
/return	
	
|**
 ----------------------------
 Wait for the mob to be within kill/stick range, then issue /attack on command
 Calls chkCombatState while in the combatLoop
 ----------------------------
**|
Sub killTarget
	/echo killTarget
	/if (${Zone.ShortName.Equal[${zoneRequest}]}) /return
	/if (!${Target.ID} || ${Target.Type.Equal[PC]}) /return
	/if (!${bln_validTGT}) /return
	/if (${bln_TGTDead})   /return
	/if (${Navigation.Active}) /navigate stop
	
	|--check camp distance
	:campCheck
	/if (${Math.Distance[${Me.Y},${Me.X}:${int_campY},${int_campX}]} > ${int_campRadius}) {
		/if (!${Navigation.Active}) /navigate waypoint bot_pull_nav
		|/echo moving back to camp
		/delay 5
		/goto :campCheck
	}

	|--check the distance, if its out of melee range/aggro range, lets wait a second
	/face fast
	/declare int_waited int local 0
	:distanceWaitLoop
		/varcalc int_waited ${int_waited}+1
		/if (${int_waited} > 15) /return
		/if (!${Target.ID}) 	 /return
		/delay 5
		/if (${Target.Distance} > ${int_campRadius}) {
			/if (${SpawnCount[npc radius ${int_campRadius} range ${int_minTLevel} ${int_maxTLevel}]} > 0) {
				/echo Something already in camp, changing target
				/target npc radius ${int_campRadius} range ${int_minTLevel} ${int_maxTLevel}
				/varset int_targetID ${Target.ID}
				/delay 5
				/goto :killMob
			} else {
				/echo Distance not covered! ${Target.Distance}::${int_waited} ${Target.Distance} > ${int_campRadius}
				/delay 5
				/goto :distanceWaitLoop
			}
		}
		
	:killMob
	|--issue kill command
	/docommand /${cmdChannel} KillMob ${Target.ID} "${Target.Name}" ${Time.Time24}
	
	/if ((${SpawnCount[npc radius ${int_campRadius}]} > 1) && (${Me.Class.ShortName.Equal[SHD]}) && ${Me.SpellReady[${spell_aehate}]} ) {
		|/echo ${Me.SpellReady[${spell_aehate}]} Cast ${spell_aehate} ${spell_aehateGem} 5s
		/call MQ2Cast "${spell_aehate}" ${spell_aehateGem}
	}
	
	/if ((${SpawnCount[npc radius ${int_campRadius}]} > 1) && ${Me.Class.ShortName.Equal[WAR]} && ${Me.CombatAbilityReady[Area Taunt]}) {
		|/echo ${Me.CombatAbilityReady[Area Taunt]}
		/doability "Area Taunt"
	} else /if ((${SpawnCount[npc radius ${int_campRadius}]} > 1) && ${Me.Class.ShortName.Equal[WAR]} && ${Me.AltAbilityReady[Rampage]}) {
		/call MQ2Cast "Rampage" alt
	}
	
	/if (!${Me.Combat}) {
		/attack on
	}
	
	/doevents flush
	
	|--while in combat do these things
:combatLoop
		/call chkCombatState
		/if (${int_targetID} != ${Target.ID}) /return
		/if (${Target.Type.NotEqual[NPC]}) /return
		/if (${Target.Distance} > ${int_campRadius}) /goto :distanceWaitLoop 

		/if (!${bln_TGTDead}) {
			/if ((${Me.TargetOfTarget.ID} != ${Me.ID}) && !${Target.Fleeing}) {
				/if ((${Me.Class.ShortName.Equal[SHD]})  && ${Me.SpellReady[${spell_hate}]}) {
					|/echo ${Me.SpellReady[${spell_hate}]} Cast ${spell_hate} ${spell_hateGem} 5s
					/call MQ2Cast "${spell_pull}" ${spell_pullGem}
				} else /if (${Me.Class.ShortName.Equal[WAR]} && (${Me.CombatAbilityReady[${war_ca_hate_1}]})) {
					/doability "${war_ca_hate_1}"
				} else /if (${Me.Class.ShortName.Equal[WAR]} && (${Me.CombatAbilityReady[${war_ca_hate_2}]})) {
					/doability "${war_ca_hate_2}"

				} 
			} 
			/goto :combatLoop
		} else {
			/echo target is dead, return
			/return
		}
/return

Sub chkLDONCompletion
	/echo chkLDONCompletion for ${ldonType} ${int_killCount} dead.
	|-- Make sure the Adventure window is open
	/if (!${Window[AdventureRequestWnd].Open}) {
		/keypress alt+v
		/delay 1s
	}

	|-- Check if the Adventure is complete
	/if (${Window[AdventureRequestWnd].Child[AdvRqst_NPCText].Text.Find[You are not currently]} > 0) /varset missionComplete TRUE
	/if (${Window[AdventureRequestWnd].Child[AdvRqst_NPCText].Text.Find[The wicked immortals]} > 0)  /varset missionComplete TRUE
	
	/if (${SpawnCount[npc radius 100]} > 0) /return
	
	| Requires zoning back to ${zoneRequest}
	/if (${missionComplete}) {
		/echo Mission has been completed leaving zone
		/declare i int local 1
		/declare originAttempt int local 0
		/declare zoneRequestAttempt int local 0
		
		/echo Mission has been completed zoning back to base zone ${zoneRequest} delaying 45s to finish looting etc
		|-- kill all group member macros, end melee, and twisting
		/delay 45s
		/squelch /bcg  //end
		/docommand /${cmdChannel} //keypress esc
		/docommand /${cmdChannel} //keypress esc
		/delay 10
		/docommand /${cmdChannel} //stand on
		/docommand /${cmdChannel} //nav stop

		/delay 15s
		
		/varset missionComplete TRUE
		/docommand /${cmdChannel} //keypress esc
		/docommand /${cmdChannel} //keypress esc
		
		
		|-- return to guild lobby
		/g Returning to Lobby ${Time.Time24} Origin Ready: ${Me.AltAbilityReady[Origin]}
		/call OriginToLobby
		/call ResetAtLobby
		
	}
	
	
	|-- Reset Adventure variables now that we are complete
	/if (${missionComplete}) {
		/g ${Time.Time24} Mission Complete, resetting variables, and starting this over again ${Time.Time24}
		/varset inMission 		FALSE
		/varset haveMission 	FALSE
		/varset missionComplete FALSE
		/varset int_killCount 		0
	}
		
/return


|**
 ----------------------------
 chkCombatState
 ----------------------------
 A determination call, to see if current target is dead, or otherwise not
 a valid target anymore
 ----------------------------
**|
Sub chkCombatState
	/if (${Target.Type.NotEqual[NPC]}) 		 /varset bln_TGTDead TRUE
	/if (${Target.Type.Equal[Item]})		 /varset bln_TGTDead TRUE
	/if (!${Target.ID}) 					 /varset bln_TGTDead TRUE
	/if (${bln_TGTDead} && ${SpawnCount[npc radius ${int_campRadius}]} == 0 && ${bln_looting}) /call chkLoot
/return

|**
 ----------------------------
 chkUtils
 ----------------------------
 Here we check mana of the cleric & the puller
 Here we check the endurance of the puller
 Here we check the hitpoints of the puller

 ----------------------------
**|

Sub chkUtils
	/if (${SpawnCount[npc radius ${int_campRadius}]} > 0) /return
	/varset bln_wait4Mana	FALSE
	/varset	bln_wait4End	FALSE
	/varset bln_wait4HP		FALSE

	/echo chkUtils

	:chkUtilLoop
		
		|/call chkBuffs
		/call chkMana
		/call chkEndurance
		/call chkHP
		/if (${strPullType.NotEqual[SPELL]}) {
			| ${component} ${count} ${compType} ${summoner} ${reagent}
			/call chkComponentsAll
		}
		/if (${bln_wait4Mana} || ${bln_wait4End} || ${bln_wait4HP}) {
			/echo Waiting for : mana: ${bln_wait4Mana} endurance: ${bln_wait4End} hitpoints: ${bln_wait4HP}
			/if (${SpawnCount[npc radius ${int_campRadius}]} > 0) /return
			/if (!${Me.Sitting}) /sit on 
			/delay 5s
			/goto :chkUtilLoop
		}
		/if (${Me.Sitting}) /sit off
/return

Sub chkMana
	/varset bln_wait4Mana FALSE
	/if ((${int_groupCLRidx} != -1) && (${Group.Member[${int_groupCLRidx}].PctMana} < ${int_clrManaFloor})) {
		/echo Cleric mana ${Group.Member[${int_groupCLRidx}].PctMana} < ${int_clrManaFloor}
		/varset bln_wait4Mana TRUE
	}
	/if ( (${int_groupENCidx} != -1) &&  (${Group.Member[${int_groupENCidx}].PctMana} < ${int_encManaFloor})) {
		/echo Enc mana ${Group.Member[${int_groupENCidx}].PctMana} < ${int_encManaFloor}
		/varset bln_wait4Mana TRUE
	}
	
	/if (${strPullType.Equal[SPELL]} && (${Me.PctMana} <  ${int_myManaFloor})) {
		/echo  ${strPullType} My mana ${Me.PctMana} < ${int_myManaFloor}
		/varset bln_wait4Mana TRUE
	}
	
	
/return


Sub chkEndurance
	/varset bln_wait4End FALSE
	/if (${Me.PctEndurance} < ${int_myEnduranceFloor}) 	/varset bln_wait4End TRUE
/return

Sub chkHP
	/varset bln_wait4HP FALSE
	/if (${Me.PctHPs} < ${int_myHitpointFloor}) 	/varset bln_wait4HP TRUE
/return


Sub chkBuffs

	/echo ----
	/echo Checking Buffs
	/echo IDs    ENC:${int_groupENCidx} CLR: ${int_groupCLRidx} DRU: ${int_groupDRUidx} SHM:${int_groupSHMidx}
	/echo Timers ENC:${timer_buffENC} CLR: ${timer_buffCLR} DRU: ${timer_buffDRU} SHM:${timer_buffSHM}
	/echo ----
	/if (${SpawnCount[npc radius ${int_campRadius}]} > 0) /return
	
	/declare int_wait int local 0
	
	|-- check to see if there is an echanter
	/if (${int_groupENCidx} != -1) {
		/if (${timer_buffENC} == 0) {
			|-- Check for Haste
			/if (!${Me.Buff[Hastening of Salik].ID} || (${Me.Buff[Hastening of Salik].ID} && ${Me.Buff[Hastening of Salik].Duration.TotalSeconds} < 45)) {
				/g Requesting Haste from ${str_groupENCname}
				/dgt ${str_groupENCname} doSpecificBuffOnChar Hastening of Salik
				/varset timer_buffENC 30s
				/varset int_wait ${int_wait} + 5
			}
			|-- Check for Mana
			|/if (!${Me.Buff[Voice of Clairvoyance].ID}) {
			|	/g Requesting VOC from ${str_groupENCname}
			|	/dgt ${str_groupENCname} doSpecificBuffOnChar Voice of Clairvoyance
			|	/varset timer_buffENC 30s
			|	/varset int_wait ${int_wait} + 5
			|}

		}
	}
	|-- check to see if there is a druid
	/if (${int_groupDRUidx} != -1) {
		/if (${timer_buffDRU} == 0) {
			|-- Check for 9
			/if (!${Me.Buff[Blessing of Steeloak].ID} || (${Me.Buff[Blessing of Steeloak].ID} && ${Me.Buff[Blessing of Steeloak].Duration.TotalSeconds} < 45)) {
				/g Requesting Bo9 from ${str_groupDRUname}
				/dgt ${str_groupDRUname} doSpecificBuffOnChar Blessing of Steeloak
				/varset int_wait ${int_wait} + 5
				/varset timer_buffDRU 30s
			}
			|-- Check for DS
			/if (!${Me.Buff[Legacy of Nettles].ID} || (${Me.Buff[Legacy of Nettles].ID} && ${Me.Buff[Legacy of Nettles].Duration.TotalSeconds} < 45)) {
				/g Requesting DS from ${str_groupDRUname}
				/dgt ${str_groupDRUname} doSpecificBuffOnChar Legacy of Nettles
				/varset int_wait ${int_wait} + 5
				/varset timer_buffDRU 30s
			}
		}
		
	}
	
	|-- check to see if there is a cleric
	/if (${int_groupCLRidx} != -1) {
		/if (${timer_buffCLR} == 0) {
			|-- if there is a druid, then we want the mark, else, virtue (well, whatever it should be)
			/if (${int_groupDRUidx} != -1) {
				/if (!${Me.Buff[Balikor's Mark].ID} || (${Me.Buff[Balikor's Mark].ID} && ${Me.Buff[Balikor's Mark].Duration.TotalSeconds} < 45)) {
					/g Requesting Symbol from ${str_groupCLRname}
					/dgt ${str_groupCLRname} doSpecificBuffOnChar Balikor's Mark
					/varset int_wait ${int_wait} + 5
					/varset timer_buffCLR 30s
				}
			} else {
				/if ((!${Me.Buff[Hand of Virtue].ID} && !${Me.Buff[Blessing of Steeloak].ID}) || (${Me.Buff[Hand of Virtue].ID} && ${Me.Buff[Hand of Virtue].Duration.TotalSeconds} < 45)) {
					/g Requesting Aegolism from ${str_groupCLRname}
					/dgt ${str_groupCLRname} doSpecificBuffOnChar Hand of Virtue
					/varset int_wait ${int_wait} + 5
					/varset timer_buffCLR 30s
				}
			}
			
		}
	}
	
	|-- check to see if there is a shaman
	/if (${int_groupSHMidx} != -1) {
		/if (${timer_buffSHM} == 0) {
			|-- Check for Focus
			/if (!${Me.Buff[Talisman of Wunshi].ID} || (${Me.Buff[Talisman of Wunshi].ID} && ${Me.Buff[Talisman of Wunshi].Duration.TotalSeconds} < 45)) {
				/g Requesting Focus from ${str_groupSHMname}
				/dgt ${str_groupSHMname} doSpecificBuffOnChar Talisman of Wunshi
				/varset int_wait ${int_wait} + 5
				/varset timer_buffSHM 30s
			}
			|-- Check for STR
			|/if (!${Me.Buff[Talisman of Might].ID}) {
			|	/g Requesting Might from ${str_groupSHMname}
			|	/dgt ${str_groupSHMname} doSpecificBuffOnChar Talisman of Might
			|	/varset int_wait ${int_wait} + 5
			|	/varset timer_buffSHM 30s
			|}
			|-- Check for STA
			/if (!${Me.Buff[Talisman of Fortitude].ID} || (!${Me.Buff[Talisman of Fortitude].ID} && ${Me.Buff[Talisman of Fortitude].Duration.TotalSeconds} < 45)) {
				/g Requesting Fortitude from ${str_groupSHMname}
				/dgt ${str_groupSHMname} doSpecificBuffOnChar Talisman of Fortitude
				/varset int_wait ${int_wait} + 5
				/varset timer_buffSHM 30s
			}
			|-- If there is no enchanter, we want haste too
			/if ((${int_groupENCidx} == -1 && !${Me.Buff[Hastening of Salik].ID} && !${Me.Buff[Talisman of Celerity].ID}) || (${Me.Buff[Talisman of Celerity].ID} && ${Me.Buff[Talisman of Celerity].Duration.TotalSeconds} < 45)) {
				/g Requesting Haste from ${str_groupSHMname}
				/dgt ${str_groupSHMname} doSpecificBuffOnChar Talisman of Celerity
				/varset int_wait ${int_wait} + 5
				/varset timer_buffSHM 30s
			}
		}
	}
	
	/echo Waiting ${int_wait}s for buffs
	/delay ${int_wait}s
	

	
/return

|**
 ----------------------------
 setGroupCommands
 ----------------------------
 Check the group and set the members to singing, or whatever they
 are supposed to be doing. Set the bard to sing and offtank
 ----------------------------
**|
Sub setGroupCommands
	/echo setGroupCommands
	|-- find a bard and tell them to sing their normal setup (bound to key 2 usually)

	/declare i int local 0
	/for i 0 to ${Group}
		/if (${Group.Member[${i}].Class.ShortName.Equal[BRD]}) /varset bard ${Group.Member[${i}].Name}
		/if (${Group.Member[${i}].Class.ShortName.NotEqual[WAR]} && ${Group.Member[${i}].Class.ShortName.NotEqual[CLR]} && ${Group.Member[${i}].Class.ShortName.NotEqual[PAL]} && ${Group.Member[${i}].Class.ShortName.NotEqual[SHD]} && ${Group.Member[${i}].Class.ShortName.NotEqual[BRD]}) /varset looter ${Group.Member[${i}].Name}
	/next i
	|-- set the offtank 
	|   if SK is the tank we dont need offtank really.
	/if (${Me.Class.ShortName.NotEqual[SHD]}) {
		/if (${offtank.Equal[NULL]}) {
			/dex ${bard} offtankOn
		} else {
			/dex ${offtank} offtankOn
		}
		
	}
	|-- tell the bard to sing a song
	/if (${bard.NotEqual[NOT_FOUND]})  /dex ${bard} /medley melee

	|-- find not cleric/tank to loot
	/if (${looter.NotEqual[NOT_FOUND]}) /dgt ${looter} lootOn ALL
	
	|-- turn on melee and aggro
	/varset bln_tanking		TRUE
	/varset bln_taunting	TRUE
	
/return

|**
 ----------------------------
 setSupportIDs
 ----------------------------
 Here we set the id of the group's cleric and other support classes.
 If we are in a raid setup, we handle that too as a 'local ID' instead of 'group ID'
 ----------------------------
**|
sub setSupportIDs
	/if (${bln_useGroup}) {
		/declare gmember int local 0
		/for gmember 0 to ${Group}
			|-- Cleric
			/if (${Group.Member[${gmember}].Class.ShortName.Equal[CLR]}) {
				/echo Setting int_groupCLRidx to ${gmember}
				/varset int_groupCLRidx ${gmember}
				/varset str_groupCLRname ${Group.Member[${gmember}].Name}
			} else /if (${Group.Member[${gmember}].Class.ShortName.Equal[ENC]}) {
				/echo Setting int_groupENCidx to ${gmember}
				/varset int_groupENCidx ${gmember}
				/varset str_groupENCname ${Group.Member[${gmember}].Name}
			} else /if (${Group.Member[${gmember}].Class.ShortName.Equal[DRU]}) {
				/echo Setting int_groupDRUidx to ${gmember}
				/varset int_groupDRUidx  ${gmember}
				/varset str_groupDRUname ${Group.Member[${gmember}].Name}
			} else /if (${Group.Member[${gmember}].Class.ShortName.Equal[SHM]}) {
				/echo Setting int_groupSHMidx to ${gmember}
				/varset int_groupSHMidx ${gmember}
				/varset str_groupSHMname ${Group.Member[${gmember}].Name}
			}
		/next gmember
		
		|-- Friendly warning
		/if (${int_groupCLRidx} == -1) {
			/beep
			/echo !! WARNING !! No Cleric Found, you are brave!
		}
	} else {
		|-- Raid looping not implemented yet because I am lazy
	}

/return 


Sub chkGroup
	/if (${Group.GroupSize} == 6) /return
	/echo chkGroup: Group isn't formed
	
	/declare i int local 1
	/for i 1 to 5
		/invite ${groupMember_${i}}
		/delay 1s
	/next i
/return



|**
 ----------------------------
 resetCamp
 ----------------------------
 Before each pull session, tell everyone to go back to the current camp
 ----------------------------
**|

Sub resetCamp
	/docommand /${cmdChannel}	//nav wp camp${int_currentCamp}
/return
		

|**
 ----------------------------
 Initialization
 ----------------------------
 Here we declare variables
 Eventually this needs to be pulled from an INI per zone and per puller!
 ----------------------------
**|
Sub variant_initialize(string _channel, string _announce, bool _useDownFlags, bool _highRisk)

	|-- variant specific vars
	/declare inMission 				bool 	outer 	FALSE
	/declare haveMission 			bool 	outer 	FALSE
	/declare ldonType	 			string 	outer 	NOAVAIL
	/declare ldonEntrance 			string 	outer 	unearthed_grave
	/declare bln_useGroup			bool	outer	TRUE
	/declare zoneRequest  			string  outer   ${Zone.ShortName}
	/declare adventureGiver         string  outer   ${Ini[INI_ldonInfo,${zoneRequest},adventureGiver]}
	/declare zoneMagus         		string  outer   ${Ini[INI_ldonInfo,[${zoneRequest}],magus]}

	/declare bard 					string 	outer NOT_FOUND
	/declare looter 				string 	outer NOT_FOUND
	
	/if (${zoneRequest.Equal[nro]}) {
		/varset	zoneMagus "North Ro" 
	} else /if (${zoneRequest.Equal[sro]}) {
		/varset	zoneMagus "South Ro" 
	} else /if (${zoneRequest.Equal[butcher]}) {
		/varset zoneMagus "Butcherblock"
	} else /if (${zoneRequest.Equal[everfrost]}) {
		/varset zoneMagus "Everfrost"
	} else /if (${zoneRequest.Equal[ecommons]}) {
		/varset zoneMagus "Commonlands"
	}
	
	
	/echo setup zoneRequest: ${zoneRequest} adventureGiver: ${adventureGiver}
	
	/declare zoneStart              string  outer   lfaydark
	/declare zoneMission 			string 	outer 	mmcd
	|--camp counts
	/declare int_currentCamp		int		outer	1
	/declare int_campCount			int 	outer	1

	/declare missionComplete        bool	outer	FALSE

	/declare dtIN                   int     outer   9999
	/declare wpIN                   string  outer   notset
	/declare dtOUT					int     outer   9999
	/declare int_xOUT				int		outer 	0
	/declare int_yOUT				int 	outer 	0
	/declare int_zOUT				int		outer	0
	/declare killTarget             string  outer   NULL
	/declare int_killCount 				int 	outer 	0
	
	|--group members
	/declare groupMember_0			string	outer  	${Group.Member[0].Name}
	/declare groupMember_1			string	outer  	${Group.Member[1].Name}
	/declare groupMember_2			string	outer  	${Group.Member[2].Name}
	/declare groupMember_3			string	outer  	${Group.Member[3].Name}
	/declare groupMember_4			string	outer  	${Group.Member[4].Name}
	/declare groupMember_5			string	outer  	${Group.Member[5].Name}
	|--loot
	/varset bln_looting			FALSE
	/if (${bln_looting}) 			/call EnableLooting
	
	|--offtank
	/declare offtank string	outer   NULL
	/if (${Defined[_offtank]} || ${_offtank.NotEqual[NULL]}) /varset offtank ${_offtank}
	
	|--highrisk?
	/declare bln_highRisk			bool	outer	FALSE	
	/if (${Defined[_highRisk]} || ${_highRisk} != FALSE) /varset bln_highRisk ${_highRisk}
	
	|--melee plugin/aggro for the requester
	/varset bln_tanking TRUE
	
	|--command channel setup
	/if (!${Defined[cmdChannel]}) /declare cmdChannel string	outer	bcga
	/varset cmdChannel bcga
	/if (${Defined[_channel]}) /varset cmdChannel ${_channel}
	/echo 	cmdChannel is ${cmdChannel}
	/docommand /${cmdChannel}	//speed 1.25
	
	|--announce channel set
	/if (!${Defined[announceChannel]}) /declare announceChannel string	outer	bcga
	/varset announceChannel bcga
	/if (${Defined[_announce]}) /varset announceChannel ${_announce}
	/echo announceChannel is ${announceChannel}
	/docommand /${cmdChannel}	//speed 1.25

	|--downflags 
	/declare useDownFlags	bool	outer	TRUE
	/if (${Defined[_useDownFlags]} && !${_useDownFlags}) /varset useDownFlags FALSE
	
	|--radii
	/declare int_pcCount			int 	outer   ${SpawnCount[PC]}
	/declare int_campRadius			int		outer	55
	/declare int_alert2Radius		int 	outer 	350
	/declare int_campPullRadius		int		outer	350
	/declare int_maxRadius			int		outer	300
	/declare int_minZHeight			int		outer 	-1500
	
	|-- use 40 for POFire
	/declare int_maxZHeight			int		outer	4000
	
	|--target information
	/declare int_minTLevel			int		outer	40
	/declare int_maxTLevel			int		outer	75
	/declare bln_validTGT			bool	outer	FALSE
	/declare bln_TGTDead			bool	outer	FALSE
	/declare bln_TGTLocal			bool	outer	FALSE
	/declare int_distTGT			int		outer	0
	/declare int_distTGTPredict		int		outer	0
	/declare int_alertCount			int		outer	0
	
	|--utility floors
	/declare int_myHitpointFloor	int		outer	60
	/declare int_myEnduranceFloor	int		outer	0
	|-- note my mana floor only matters if I am a spell casting puller
	/declare int_myManaFloor		int		outer	20 
	/declare int_clrManaFloor		int		outer	20
	/declare int_encManaFloor		int		outer	0
	/declare bln_wait4Mana			bool	outer	FALSE
	/declare bln_wait4HP			bool	outer	FALSE
	/declare bln_wait4End			bool	outer	FALSE
	
	|--spell & support definitions are declared in xiris_melee.inc
	
	|--set up the camp logic
	/if (!${Defined[int_campX]}) /declare int_campX 				int outer ${Me.X}
	/if (!${Defined[int_campY]}) /declare int_campY 				int outer ${Me.Y}
	/if (!${Defined[int_campZ]}) /declare int_campZ 				int outer ${Me.Z}
	
	
	/declare timer_taunt            timer 	outer    3s

	
	|--set the camp spot
	/call setCamp

	|--set the puller type 
	/declare strPullType	string	outer	RANGED
	

	| MELEE DPS CLASS ENUMERATION - Endurance Focus
	/if (${Select[${Me.Class.ShortName},ROG,BER,MNK]}) {
		/varset strPullType RANGED
	}
	
	| MELEE DPS CLASS ENUMERATION - Mana Focus
	/if (${Select[${Me.Class.ShortName},BST,RNG,BRD,PAL]}) {
		/varset strPullType RANGED
	}	
	
	| TANK CLASS ENUMERATION
	/if (${Select[${Me.Class.ShortName},WAR]}) {
		/varset strPullType RANGED
	}		
	
	| TANK CASTER CLASS ENUMERATION
		/if (${Select[${Me.Class.ShortName},SHD]}) {
		/varset strPullType SPELL
	}	

	
	/declare int_obstacleCNT		int 	outer 	0
	/declare bln_noLOS				bool	outer	FALSE	
	/declare bln_tooClose			bool	outer	FALSE
	/declare bln_moveFail			bool    outer 	FALSE
	
	|--find the support members of the group for use in keeping up buffs
	/declare int_groupCLRidx int outer -1
	/declare int_localCLRid int outer -1
	/declare str_groupCLRname string outer NULL
	/declare timer_buffCLR timer	outer  1s

	/declare int_groupENCidx int outer -1
	/declare int_localENCid int outer -1
	/declare str_groupENCname string outer NULL
	/declare timer_buffENC timer	outer  1s
	
	/declare int_groupDRUidx int outer -1
	/declare int_localDRUid int outer -1
	/declare str_groupDRUname string outer NULL
	/declare timer_buffDRU timer	outer  1s

	/declare int_groupSHMidx int outer -1
	/declare int_localSHMid int outer -1
	/declare str_groupSHMname string outer NULL
	/declare timer_buffSHM timer	outer 1s
		
	/call setSupportIDs
	
/return





Sub setAlerts
	|=================================
	|--- specific zone mobs to avoid;
	|=================================
	/squelch /alert clear 1
	/squelch /alert add 1 "All Powerful Gnome"
	/squelch /alert add 1 "Guardian of Doomfire"
	/squelch /alert add 1 "The Fabled Kobold Noble"
	/squelch /alert add 1 "The Fabled Kobold Priest"
	/squelch /alert add 1 "The Fabled Kobold Champion"
	/squelch /alert add 1 "The Fabled Solusek Kobold King"
	/squelch /alert add 1 "The Fabled Death Beetle"
	/squelch /alert add 1 "fire giant warrior"
	/squelch /alert add 1 "neiroth"
	/squelch /alert add 1 "zordak ragefire"
	/squelch /alert add 1 "lord nagafen
	/squelch /alert add 1 "magus rokyl"
	/squelch /alert add 1 "fire giant wizard"
	/squelch /alert add 1 "Warlord Skarlon"
	/squelch /alert add 1 "King Tranix"
	/squelch /alert add 1 "GREEmoteTrap"
	/squelch /alert add 1 "The Wailing Sister"
	/squelch /alert add 1 "Hatchling"
	/squelch /alert add 1 "Hedge Trigger"
	/squelch /alert add 1 "Odaen"
	/squelch /alert add 1 "Ptav M'sha"
	/squelch /alert add 1 "Dvoin M'sha"
	/squelch /alert add 1 "Mnat M'sha"
	/squelch /alert add 1 "Aganetti the Keeper"
	/squelch /alert add 1 "Cynosure Kvanjji"
	/squelch /alert add 1 "Qkav`d the Fourth Arbitor"
	/squelch /alert add 1 "Svi`pral the Second Arbitor"
	/squelch /alert add 1 "Vishai the First Arbitor"
	/squelch /alert add 1 "Ytvagi the Third Arbitor"
	/squelch /alert add 1 "General Reparm"
	/squelch /alert add 1 "General Druav Flamesinger"
	/squelch /alert add 1 "Blazzax the Omnifiend"
	/squelch /alert add 1 "Pyronis"
	/squelch /alert add 1 "Magmaton"
	/squelch /alert add 1 "Arch Mage Yozanni"
	/squelch /alert add 1 "Councilman"
	/squelch /alert add 1 "Pixtt"
	/squelch /alert add 1 "Mass of Stone"
	/squelch /alert add 1 "Zelnithak"
	/squelch /alert add 1 "remains of vah"
	/squelch /alert add 1 "a guardian spirit"
	/squelch /alert add 1 "spectre of corruption"
	/squelch /alert add 1 "barban"
	/squelch /alert add 1 "Tantisala"
	/squelch /alert add 1 "Pixtt Uxnikk"
	/squelch /alert add 1 "Pixtt Kekken"
	/squelch /alert add 1 "A Kyv Runner"
	/squelch /alert add 1 "Gamesh"
	/squelch /alert add 1 "Scribe Gurru"
	/squelch /alert add 1 "an enslaved yunjo"
	/squelch /alert add 1 "etumer"
	/squelch /alert add 1 "the wailing sister"
	/squelch /alert add 1 "untel"
	/squelch /alert add 1 "Warder Cecilia"
	/squelch /alert add 1 "Zun`Muram Votal"
	/squelch /alert add 1 "Pixtt Votal"
	/squelch /alert add 1 "Packmaster Skoiat Pizak"
	/squelch /alert add 1 "a hungry yunjo"
	/squelch /alert add 1 "Smith Rondo"
	/squelch /alert add 1 "Caridwi"
	/squelch /alert add 1 "a waiting warder"
	/squelch /alert add 1 "a yunjo"
	/squelch /alert add 1 "Velketor"
	/squelch /alert add 1 "a hissing"
	/squelch /alert add 1 "the walls"
	/squelch /alert add 1 "a chill"
	/squelch /alert add 1 "a massive burrower"
	/squelch /alert add 1 "The Burrower Beast"
	/squelch /alert add 1 "Trydan Faye"
	/squelch /alert add 1 "Rhalliq Trell"
	/squelch /alert add 1 "Alekson Garn"
	/squelch /alert add 1 "a bitten victim"
	/squelch /alert add 1 "a petrified colossal tree"
	/squelch /alert add 1 "a hollow tree"
	/squelch /alert add 1 "a trap"
	/squelch /alert add 1 "flavor text"
	/squelch /alert add 1 "ten"
	/squelch /alert add 1 "six"
	/squelch /alert add 1 "two"
	/squelch /alert add 1 "a hissing"
	/squelch /alert add 1 "four"
	/squelch /alert add 1 "eight"
	/squelch /alert add 1 "three"
	/squelch /alert add 1 "ten"
	/squelch /alert add 1 "TerrorSpawner"
	/squelch /alert add 1 "a shimmering orb"
	/squelch /alert add 1 "aedispellph"
	/squelch /alert add 1 "aerainph"
	/squelch /alert add 1 "from no where"
	/squelch /alert add 1 "mini named controller"
	/squelch /alert add 1 "the hair"
	/squelch /alert add 1 "a murkglider licheglider"
	/squelch /alert add 1 "a murkglider soulstalker"
	/squelch /alert add 1 "Ixt Imnes the Ironhoof"
	/squelch /alert add 1 "Ikaav Salisa Mexmielk"
	/squelch /alert add 1 "Dragorn Champion"
	/squelch /alert add 1 "Filligno the Slayer"
	/squelch /alert add 1 "Keeper of Blood" |note spawns in spot you can't nav to
	
	|=================================
	|--- specific zone mobs to hunt;
	|=================================
	/squelch /alert clear 2
	|--Hunter Cycle--|
	/squelch /alert add 2 "froglok hunter"
	/squelch /alert add 2 "Oracle Froskil"
	/squelch /alert add 2 "Harbinger Josk"
	/squelch /alert add 2 "Knight Dragol"
	/squelch /alert add 2 "Vessel Fryn"
	/squelch /alert add 2 "Keeper Sepsis"
	/squelch /alert add 2 "Ebon lotus"
	/squelch /alert add 2 "Ffroaak"
	/squelch /alert add 2 "Dreadlord Dekir"
	/squelch /alert add 2 "Partisan Yinlen"
	/squelch /alert add 2 "Doom"
	/squelch /alert add 2 "Throkkok"
	/squelch /alert add 2 "Hierophant Ixyl"
	/squelch /alert add 2 "Master Fasliw"
	/squelch /alert add 2 "Sigra"

	|-- Forager Cycle--|
	/squelch /alert add 2 "froglok forager"
	/squelch /alert add 2 "Champion Thenrin"
	/squelch /alert add 2 "Commander Sils"
	/squelch /alert add 2 "Titail Sinok"
	/squelch /alert add 2 "Bloodeye"
	/squelch /alert add 2 "Dreadlord Fanrik"
	/squelch /alert add 2 "Hangman"
	/squelch /alert add 2 "Dragontail"
	/squelch /alert add 2 "Squire Glik"
	/squelch /alert add 2 "Klok Denris"
	/squelch /alert add 2 "Crusader Zoglic"
	/squelch /alert add 2 "Harbinger Dronik"
	/squelch /alert add 2 "Keeper Lasnik"
	/squelch /alert add 2 "Silvermane"
	/squelch /alert add 2 "Thruke"
	/squelch /alert add 2 "Flayhte"
	/squelch /alert add 2 "Champion Arlek"
	
	|-- Anguish Signets--|
	/squelch /alert add 2 "turncoat"
	
	|-- LDON Hunter
	| /squelch /alert add 2 "Keeper of Blood" |note spawns in spot you can't nav to
	/squelch /alert add 2 "Yavrin"
	/squelch /alert add 2 "Jerranad"
	
	
	
	|-- etc--|
	/squelch /alert add 2 "night watchman"
	/squelch /alert add 2 "officiator"
	/squelch /alert add 2 "Ulyist"
	/squelch /alert add 2 "Keeper of Blood"
	/squelch /alert add 2 "Yavrin"
	/squelch /alert add 2 "Bial the Blade"
	/squelch /alert add 2 "Jerrand"
	/squelch /alert add 2 "Sikl"
	/squelch /alert add 2 "Giddib"
	/squelch /alert add 2 "officiator"
	
	
	
	/squelch /alert clear 3
	/squelch /alert add 3 "All Powerful Gnome"

/return

Sub Event_TooClose
	/echo Event_TooClose
	/varset bln_tooClose TRUE
/return

Sub Event_NoLOS
	/echo Event_NoLOS
	/varset bln_noLOS TRUE
/return


Sub Event_EndMac
	/bc Someone told me to end it! ${Time.Time24}
	/g Someone told me to end it! ${Time.Time24}
	/delay 1s
	/docommand /${cmdChannel}  //end
	/delay 2m
	/docommand /${cmdChannel}  //icampdesk
	/end
/return





