|**
----------------------------
BOT_PULL.mac
----------------------------
This macro is configured for use by an SK, but may work for any class
Modify the BOT_PULL_zoneinfo.ini file for use in a specific zone
______________________________________________
REVISION HISTORY
    09.16.10    xiris  	Initial Revision
    10.07.10	xiris  	Added Polygon Bounding (removed later as unecessary)
    11.07.15	xiris  	Hacked this together to just use fartaunting for specific mobs
	07.23.17    xiris  	Fixed alert list 2 (target hunter)
	07.14.18	xiris  	Removed fartaunt due to server banning it
	11.18.21	xiris	Added mq2nav for pulling now that emulator mq2 has it
	12.01.21	xiris	Added some tweaked events around pulling (NOLOS/TOOCLOSE) to handle weird edge cases
	04.10.22	xiris	Normalized arguments
	05.24.22	xiris	Reworked the pulling sub - gained performance
	05.28.22	xiris	Refactored /docommand /${cmdChannel} to be consistent globally
	06.13.22	xiris 	Changed things that were explicit commands to event requests so we don't
						rely on bcaa (and can use rsay or gsay) and was able to remove announce Channel
	12.19.22	xiris   Tweaked the incamp target acquisition to ignore alert 1
______________________________________________
REQUIRED PLUGINS
    mq2melee
    mq2cast
    mq2eqbc
    mq2debuffs
    mq2moveutils
	mq2nav
______________________
REQUIRED INCLUDES 
	xiris_common/spell_routines.inc
	xiris_common/xiris_common.inc <-- which has a ton of includes!
**|


#include xiris_common/xiris_common.inc

#Turbo 40

#define INI_zoneInfo xiris_common/xiris_pull_zoneinfo.ini

#event Zoned                "You have entered#*#"
#event Zoned                "LOADING, PLEASE WAIT..."
#event NoLOS				"#*#you cannot see your target#*#"
#event TooClose				"#*#your target is too close#*#"

Sub Main(int _pull_dist, string _channel, string _campName, bool _useDownFlags,  bool _usePull)
	/delay 5

	|-- initialize common xbot variables
	/call xbot_initialize ${Me.Name}
	
	|-- initialize variables specific to this macro
	/call variant_initialize ${_pull_dist} ${_channel} ${_campName} ${_useDownFlags} ${_usePull}

	|-- report status
	/echo Pulling >> ${Zone.Name} @ ${int_maxRadius} Range<<


	/melee aggro=1
	
	|**
	 ----------------------------
	 Main Loop
	 ----------------------------
	 If adding any routine add the call here
	 Runs in order
	 ----------------------------
	**|
	:MainLoop
		/if (${MacroQuest.GameState.Equal[CHARSELECT]} || ${MacroQuest.GameState.Equal[PRECHARSELECT]} ) /end
		/if (${Me.Casting.ID} && ${Me.Hovering}||${Window[tradewnd].Open}||${Window[lootwnd].Open}) /goto :mainLoop
		
		|-- Check to see if self needs to be cured (xiris_curing.inc)
		/call RunAllEvents
		/call chkNeedCure

		/call chkUtils
		
		/call chkZone
		
		|-- reset group to camp spot (leash) if its empty
		/if (${SpawnCount[npc radius ${int_campRadius} zradius 25]} == 0) {
			/if (${bln_looting}) /call chkLoot
			/call resetCamp
			/call RefreshXTarget
			/docommand /${cmdChannel} Disengage
			/if (${bln_looting}) /call chkLoot
			/if (!${bln_looting}) /hidecorpse npc
		}
		
		|-- run the pull/kill segment
		:getAndKill
			/call getTarget
			/if (${Target.Distance} > 20) /call pullTarget
			/if (!${Target.ID}) /goto :getAndKill
			/if (${Target.ID}) /call killTarget
			
			/echo We have killed ${int_killCount} mobs

	/goto :MainLoop
/return

Sub chkZone
	/if (${Zone.ShortName.NotEqual[${SZ_shortName}]}) {
		/if (${Zone.ShortName.Equal[${Me.BoundLocation[0]}]}) {
			/docommand /${cmdChannel}  I died! GTFO! ${Time}
			/end
		}
	}
/return


Sub setRSTVars
	/varset	bln_validTGT	FALSE
	/varset bln_TGTDead		TRUE
	/varset bln_TGTLocal	FALSE
	/target clear
/return


Sub setTGTAlert
	/echo setTGTAlert ${Target.ID} ${Target.Name}
	/alert add 1 id ${Target.ID}
	/keypress esc
/return

|**
 ----------------------------
 getTarget
 ----------------------------
 Checks to see if there are any mobs within camp, if so, it targets them indiscriminately
 otherwise, it attempts to target a NPC that does not fall in the alert list
 Calls chkTargetValid once a target has been found, if that returns as valid, it continues
 ----------------------------
**|
Sub getTarget
	/if (${Me.Sitting}) /sit off
	/squelch /target clear

	/echo getTarget
	:AcquireLoop
		| set the vars like target validity to FALSE so we can check
		/call setRSTVars
		/echo SpawnCount: ${SpawnCount[npc radius ${int_campRadius} zradius 15]}
		/echo Target.ID: ${Target.ID}
		|----------If I am getting smacked in camp, kill it
		/if (${SpawnCount[npc radius ${int_campRadius} zradius 15]} > 0) {
			/call TrueTarget ${NearestSpawn[npc radius ${int_campRadius} zradius 15].ID} 
			/if (${Target.ID} && ${Target.Type.Equal[NPC]} || ${Target.Type.Equal[PET]}) {
				/echo Something is hitting me, killing it!
				/varset bln_validTGT	TRUE
				/goto :return
			}
			
		} else {
			|----------Alert 1 is never target, Alert 2 is hunter targets--------
			/if (${SpawnCount[npc radius ${int_campRadius} zradius 15 noalert 1]} > 0) {
				/call TrueTarget ${NearestSpawn[npc radius ${int_campRadius} zradius 15 noalert 1].ID} 
				/echo NPC in camp (R:${int_campRadius}), killing: Distance: ${Target.Distance3D}
				/delay 5
			} else /if (${SpawnCount[npc alert 2 radius ${int_alert2Radius} range ${int_minTLevel} ${int_maxTLevel} zradius ${int_zRadius} noalert 1]} > 0) {
				/call TrueTarget ${NearestSpawn[npc alert 2 radius ${int_alert2Radius} range ${int_minTLevel} ${int_maxTLevel} zradius ${int_zRadius}  noalert 1].ID}
				/echo NPC on alert 2 is up, killing: Distance: ${Target.Distance3D}
				/delay 5
			} else /if (${SpawnCount[npc noalert 1 radius ${int_maxRadius} range ${int_minTLevel} ${int_maxTLevel} zradius ${int_zRadius}]} > 0) {
				/echo No NPCs on the alert 2 list are up, trying random NPC
				/call TrueTarget ${NearestSpawn[npc noalert 1 radius ${int_maxRadius} range ${int_minTLevel} ${int_maxTLevel} zradius ${int_zRadius}].ID} 
				/delay 5
			}



			|----------Target Validation
			/if (${Target.ID} && (${Target.Distance} <= ${int_campRadius}) && ${Target.DistanceZ} < 25) {
				|--if it is close, its valid;
				/varset bln_validTGT	TRUE
			} else {
				|--check the target
				/if (${Target.ID}) /call chkTargetValid
			}
			
			
			|--restart if there is no valid target
			/if (!${bln_validTGT}) {
				|-- if there is more than 1 camp in our dataset, we can start walking through the camps
				/if (${int_campCount} > 1) {
						/echo Checking on Moving the Camp
						:MoveCamp
						|-- if we are less than the current camp and we are incrementing, move forward
						/if (${int_currentCamp} == ${int_campCount}) {
							/varset bln_increment FALSE
						} else /if (${int_currentCamp} == 1) {
							/varset bln_increment TRUE
						}

						/if (${bln_increment}) {
							/varset int_currentCamp ${int_currentCamp}+1
							/docommand /${cmdChannel} Incrementing Camp to ${int_currentCamp}
						} else {
							/varset int_currentCamp ${int_currentCamp}-1
							/docommand /${cmdChannel} Decrementing Camp to ${int_currentCamp}
						}
					
						/call moveCamp ${int_currentCamp}
						/delay 10
				} else {
					/if (${SpawnCount[npc noalert 1 radius ${int_maxRadius} range ${int_minTLevel} ${int_maxTLevel} zradius ${int_zRadius}]} == 0) {
						/echo No valid targets delaying 5s
						/delay 5s
					} 
				}
				/goto :AcquireLoop
			}
		}

		:return
		|--target is valid, continue
		/varset int_targetID 	${Target.ID}
		/varset bln_TGTDead		FALSE
		/varset int_distTGT 	${Int[${Target.Distance}]}
		/echo Acquired ${Target.Name} at range ${Int[${Target.Distance}]}
/return

|**
 ----------------------------
 chkTargetValid
 ----------------------------
 Checks to see if the current target passes the criteria
 If it is a valid target, bln_validTGT is assigned TRUE
 Returns to getTarget
 ----------------------------
**|
Sub chkTargetValid
	/echo chkTargetValid ${Target.Name}
	/if (${Target.Type.NotEqual[NPC]}) {
		/echo INVALID Not NPC
		/call setTGTAlert
		/return
	} 
	
	|--check if there is a path to the target
	/if (!${Navigation.PathExists[target]}) {
		/echo INVALID No Path to Target
		/call setTGTAlert
		/return
	}

	|--check to see if its a pet
	/if (${Target.Name.Find[s_pet]}) { 
		/echo INVALID Target a pet, next
		/call setTGTAlert
		/return
	}

	|--check to see if its excluded specifically
	/if (${ExcludeList.Find[${Target.CleanName}]}) { 
		/echo INVALID Target is on exclusion list, next
		/call setTGTAlert
		/return
	}
	
	|--check my target is the apropriate level
	/if ((${Target.ID}) && (${Target.Level} < ${int_minTLevel})) {
		/echo INVALID Target.Level (${Target.Level} < ${int_minTLevel})
		/call setTGTAlert
		/return
	}
	/if (${Target.Underwater} && ${Zone.ShortName.NotEqual[powater]}) {
		/echo INVALID Target.Underwater
		/call setTGTAlert
		/return
	}
	
	|--check my target is the above the apropriate z-radius floor
	/if ((${Target.ID}) && ${Int[${Target.Z}]}<${int_minZHeight}) { 
		/echo INVALID Target.Z ${Int[${Target.Z}]}<${int_minZHeight}
		/call setTGTAlert
		/return
	} 
	|--check my target is the above the apropriate z-radius ceiling
	/if ((${Target.ID}) && ${Int[${Target.Z}]}>${int_maxZHeight}) { 
		/echo INVALID Target.Z ${Int[${Target.Z}]}>${int_maxZHeight}
		/call setTGTAlert
		/return
	}
	
	/varset bln_validTGT	TRUE
/return 


|**
 ----------------------------
 Camp Subs
 ----------------------------
 Before each pull session, tell everyone to go back to the current camp
 ----------------------------
**|

Sub setCamp
	/echo \awSetting to Camp \ag${str_campName}
	/docommand /${cmdChannel} NavToWP ${str_campName}
	/navigate RecordWaypoint ${str_campName}
	|/if (${int_currentCamp} == 1) /docommand /${cmdChannel} CreateCamp camp1
	
	/varset D1X int outer ${Me.X}
	/varset D1Y int outer ${Me.Y}
	/varset D1Z int outer ${Me.Z}

	/varset int_campY ${Me.Y}
	/varset int_campX ${Me.X}
	/delay 1s
	|/mqpause on
/return

Sub resetCamp
	/echo \awResetting to Camp \ag${str_campName}
	/docommand /${cmdChannel} NavToWP ${str_campName}
	| -- don't run self back to camp its not necessary run to my pull spot instead
	/declare int_returnCount int local 0
	/nav wp ${str_campName}
	:campReturn
	/if (${Navigation.Active} && ${int_returnCount} < 30) {
		/delay 20
		/varcalc int_returnCount ${int_returnCount} +1
		/goto :campReturn
	}
	
	/nav stop
/return


Sub moveCamp(int _campNumber) 
	/echo \awMoving to Camp Number \ag${str_campName}
	/docommand /${cmdChannel} NavToWP camp${_campNumber}
	/delay 1
	:moveCampNavLoop
		/echo moveCampNavLoop
		/if (${Navigation.Active}) {
			/delay 1s
			/goto :moveCampNavLoop
		} 
	/call setCamp
/return


|**
 ----------------------------
 pullTarget
 ----------------------------
 Checks to see if we need to pull target, if so, then we initiate the pulling mechanism
 and then once aggro is established, drags the mob back to camp to be killed
 Calls AggroTarget
 Calls makecamp return
 Returns to mainLoop if a valid pull has been achieved
 ----------------------------
**|
Sub pullTarget
	/echo pullTarget
	/declare campDist int local
	/declare dist int local
	|--check to see if we have a valid target, or skip
	/declare attempt int local 0

	
	:pullLoop
		/if (!${bln_validTGT}) 				/goto :return
		/if (!${Target.ID}) 				/goto :return
		/if (${Target.Type.NotEqual[NPC]}) 	/goto :return
	
		| Start the pull by running to the target
		:RunningToTarget
		/if (!${Navigation.Active}) /navigate target

		/delay 20
		| Target in LOS, and in distance, going to aggrocheck
		/if (${Target.LineOfSight} && ${Target.Distance3D} < ${int_castDistance}) {
			/echo Target in LOS, and in distance, going to aggrocheck
			/goto :AggroCheck
		}

		| Target has me as aggrod, and in range, going to returnWithPull
		/if (${Me.TargetOfTarget.Name.Equal[${Me.Name}]} && (${Target.Distance3D} < ${int_castDistance})) {
			/echo Target has me as aggrod, and in range, going to returnWithPull
			/goto :ReturnWithPull
		} 

		| Too many attempts, returnwithpull
		/if (${attempt} > 10) {
			/echo Too many attempts, returnwithpull
			/alert add 1 "${Target.ID}"
			/target clear
			/goto :ReturnWithPull
		} 

		/if (!${Target.ID}) /goto :return
		
		/delay 10

		|-- Check to see if I don't yet have aggro
		:AggroCheck
		/echo minpull ${int_maxPullCount}
		/echo usePull ${bln_usePull}
		/echo castDist ${int_castDistance}
	| || (!${bln_usePull} && (${Target.Distance} > 25 && ${Target.LineOfSight}))
		/if (!${Me.TargetOfTarget.ID} && ((${bln_usePull} && ${Me.XTarget} < ${int_maxPullCount}) || (!${bln_usePull}))) {
 
		
			| I do not yet have aggro;
			/echo I do not have aggro, checking dist
			:AggroDistCheck 
			| Am I close enough to aggro?
			/if (${Target.Distance3D} > 200 && ${bln_usePull}) /goto :RunningToTarget
			/if (${Target.Distance3D} > 25 && !${bln_usePull}) /goto :RunningToTarget

			/if ((${bln_usePull} && (${Target.Distance} < ${int_castDistance}) && ${Target.LineOfSight}) || (!${bln_usePull} && (${Target.Distance} < 25 && ${Target.LineOfSight}))) {
				| I am, call aggro sub.
				/echo \ao Attempting to Aggro Target
				/call AggroTarget
				/varcalc attempt ${attempt} + 1
				/echo \aoAggro Attempt return ${Macro.Return}
				/if (${Me.TargetOfTarget.Name.Equal[${Me.Name}]}) 	/goto :ReturnWithPull
				/if (${Macro.Return.Equal[NOLOS]})    				/goto :RunningToTarget
				/if (${Macro.Return.Equal[CAST_FIZZLE]})    		/goto :AggroCheck
				/if (${Macro.Return.Equal[NOTARGET]}) 				/goto :return
				/if (${Macro.Return.Equal[NOMANA]})					/goto :RunningToTarget
				/if (${Macro.Return.Equal[SUCCESS]})  {
					/doevents NoLoS 
					/if (${bln_noLOS}) {
						/varset bln_noLOS FALSE
						/goto :RunningToTarget
					} else {
						/goto :ReturnWithPull 
					}
				}
			} else { 
				/goto :RunningToTarget
			}
		} else {
			| I have aggro, returning to camp
			:ReturnWithPull
			/if (${bln_usePull}) {
				/echo \agReturning to Camp with \ay${Me.XTarget}+ \agmobs.
				/navigate waypoint ${str_campName} 
				/goto :ReturnLoop
			} else {
				/if (!${Target.Aggressive}) /call AggroTarget
				/echo \agPulling is disabled, killing \ay${Me.XTarget}+ \agmobs.
				/goto :return
			}
			
			:ReturnLoop
				/delay 10
				/varcalc dist ${Math.Distance[${Me.Y},${Me.X},${Me.Z}:${D1Y},${D1X},${D1Z}]}
				/if (${dist} < ${pulltocamp}) /nav stop
				/if (${Navigation.Active})  /goto :ReturnLoop
		}
	:return
/return	



Sub AggroTarget 
	/if (${Navigation.Active}) /navigate stop
	/declare ret string local FAILED
	:TargetAggroCheck
	/if (!${Target.ID}) {
		/varset ret NOTARGET
	} else /if (!${Target.LineOfSight}) {
		/varset ret NOLOS
	} else /if (${Me.TargetOfTarget.Name.Equal[${Me.Name}]}) {
		/varset ret SUCCESS
	} else {
		| Need to aggro the mob somehow
		:AttemptAggro
		/if (!${bln_usePull}) {
			/killthis
			/varset ret SUCCESS
			/goto :return
		}
		/if (${strPullType.Equal[RANGED]}) {
			/face fast
			/delay 5
			/ranged
			/doevents TooClose
			|-- Sometimes if we aren't spell casting and using range weapons we might be too close, and cannot hit them with it.
			/if (${bln_tooClose}) {
				/echo Too Close! Handling
				/if (${Me.Class.ShortName.Equal[PAL]}) /call MQ2Cast "${spell_pull}" ${spell_pullGem} 2s
				/if (${Me.Class.ShortName.Equal[WAR]}) /call chk_warProvoke "${war_ca_hate_1}"
				/delay 1
				/if (${Me.CombatAbilityReady[Taunt]}) /doability Taunt
				/varset bln_tooClose FALSE
				/goto :TargetAggroCheck
			}
			/delay 10
			/goto :TargetAggroCheck
		} else {
			/if (${Me.PctMana} > 10) {
				/call chkSpellMemorized "${spell_pull}" TRUE ${spell_pullGem}
				/echo ${Me.SpellReady[${spell_pull}]} Cast "${spell_pull}" ${spell_pullGem} 2s
				/call MQ2Cast "${spell_pull}" ${spell_pullGem} 2s
				/doevents NoLOS
			
				
				/if (${bln_noLOS}) /varset ret NOLOS
				/if (${Macro.Return.Equal[CAST_SUCCESS]}) /varset ret SUCCESS
				/if (${Macro.Return.Equal[CAST_CANNOTSEE]}) /varset ret NOLOS
				/if (${Macro.Return.Equal[CAST_INTERRUPTED]}) /goto :AttemptAggro
	
				
			} else {
				/varset ret NOMANA
			}
		} 
	}
	:return
/return ${ret}

|**
 ----------------------------
 Wait for the mob to be within kill/stick range, then issue
 /killthis command to mq2melee
 Calls chkCombatState while in the combatLoop
 ----------------------------
**|

Sub killTarget
	/if (!${Target.ID} || ${Target.Type.Equal[PC]}) /return
	/if (!${bln_validTGT}) /return
	/if (${bln_TGTDead})   /return
	/if (${Navigation.Active}) /navigate stop
	
	/declare int_waited int local 0
	|--check camp distance
	/if (${bln_usePull}) {
		:campCheck
		/if (${Math.Distance[${Me.Y},${Me.X}:${int_campY},${int_campX}]} > ${int_campRadius}) {
			/if (!${Navigation.Active}) /navigate waypoint ${str_campName}
			/echo \agMoving back to \ao${str_campName}
			/delay 5
			/goto :campCheck
		} else {
			/if (${Navigation.Active}) /navigate stop
		}
	} else {
		/goto :killMob
	}

	|--check the distance, if its out of melee range/aggro range, lets wait a second
	/face fast
	:distanceWaitLoop
		/varcalc int_waited ${int_waited}+1
		/if (${int_waited} > 15) /return
		/if (!${Target.ID}) 	 /return
		/delay 5
		/if (${Target.Distance} > ${int_campRadius}) {
			/if (${SpawnCount[npc radius ${int_campRadius}]} > 0) {
				/echo Something already in camp, changing target
				/target radius ${int_campRadius} npc
				/varset int_targetID ${Target.ID}
				/varset bln_validTGT	TRUE
				/delay 5
				/goto :killMob
			} else {
				/echo  Distance not covered! ${Target.Distance}::${int_waited} ${Target.Distance} > ${int_campRadius}
				/delay 5
				/goto :distanceWaitLoop
			}
		}
		
	:killMob
	|--issue kill command
	/varcalc int_killCount ${int_killCount}+1
	|TODO: make kill command use cmd chanenl
	/docommand /${cmdChannel} KillMob ${Target.ID} "${Target.Name}" ${Time.Time24}
	/call ResetCastTimers
	/killthis
	/attack on
	/g Called Kill ${Target.ID} ${Target.Name} ${Time.Time24}
	
	/if ((${SpawnCount[npc radius ${int_campRadius}]} > 1) && ${Me.Class.ShortName.Equal[SHD]}  && ${Me.SpellReady[${spell_aehate}]} ) {
		/echo ${Me.SpellReady[${spell_aehate}]} Cast ${spell_aehate} ${spell_aehateGem} 5s
		/call MQ2Cast "${spell_aehate}" ${spell_aehateGem}
	}
	/if ((${SpawnCount[npc radius ${int_campRadius}]} > 1) && ${Me.Class.ShortName.Equal[WAR]} && ${Me.CombatAbilityReady[Area Taunt]}) {
		/doability "Area Taunt"
	} else /if ((${SpawnCount[npc radius ${int_campRadius}]} > 1) && ${Me.Class.ShortName.Equal[WAR]} && ${Me.AltAbilityReady[Rampage]}) {
		/call MQ2Cast "Rampage" alt
	}
	
	/if (!${Me.Combat}) {
		/killthis
	}

	
	|--while in combat do these things
	:combatLoop
		/call chkCombatState
		/if (${int_targetID} != ${Target.ID}) /return
		/if (${Target.Type.NotEqual[NPC]}) /return
		/if (${Target.Distance} > ${int_campRadius}) /goto :distanceWaitLoop 

		/if (!${bln_TGTDead}) {
			/if ((${Me.TargetOfTarget.ID} != ${Me.ID}) && !${Target.Fleeing}) {
				/if ((${Me.Class.ShortName.Equal[SHD]} || ${Me.Class.ShortName.Equal[PAL]}) && ${Me.SpellReady[${spell_hate}]}) {
					/call MQ2Cast "${spell_hate}" ${spell_hateGem}
				} else /if (${Me.Class.ShortName.Equal[WAR]} && (${Me.CombatAbilityReady[${war_ca_hate_1}]})) {
					/doability "${war_ca_hate_1}"
				} else /if (${Me.Class.ShortName.Equal[WAR]} && (${Me.CombatAbilityReady[${war_ca_hate_2}]})) {
					/doability "${war_ca_hate_2}"
				} 
			} 
			/if ((${SpawnCount[npc radius ${int_campRadius}]} > 1) && ${Me.Class.ShortName.Equal[SHD]}  && ${Me.SpellReady[${spell_aehate}]} ) {
				/echo ${Me.SpellReady[${spell_aehate}]} Cast ${spell_aehate} ${spell_aehateGem} 5s
				/call MQ2Cast "${spell_aehate}" ${spell_aehateGem}
			}
			/goto :combatLoop
		} else {
			/echo target is dead, return
		}
/return



|**
 ----------------------------
 chkCombatState
 ----------------------------
 A determination call, to see if current target is dead, or otherwise not
 a valid target anymore
 ----------------------------
**|
Sub chkCombatState
	/if (${Target.Type.NotEqual[NPC]}) 		 /varset bln_TGTDead TRUE
	/if (${Target.Type.Equal[Item]})		 /varset bln_TGTDead TRUE
	/if (!${Target.ID}) 					 /varset bln_TGTDead TRUE
	/if (${bln_TGTDead} && ${SpawnCount[npc radius ${int_campRadius}]} == 0 && ${bln_looting}) /call chkLoot
/return



|**
 ----------------------------
 chkUtils
 ----------------------------
 Here we check mana of the cleric & the puller
 Here we check the endurance of the puller
 Here we check the hitpoints of the puller

 ----------------------------
**|

Sub chkUtils
	/if (${SpawnCount[npc radius ${int_campRadius}]} > 0) /return
	/varset bln_wait4Mana	FALSE
	/varset	bln_wait4End	FALSE
	/varset bln_wait4HP		FALSE

	/echo chkUtils
	/declare int_buffDelay int local 0

	:chkUtilLoop
		
		|/call chkBuffs
		|/call chkMana
		|/call chkEndurance
		
		/if (${useDownFlags}) /call chkDownshits
		/call chkHP
		/call chkComponentsAll
		/if (!${timer_allBuffs} && !${bln_usePull}) {
			/echo \ayRequesting Buffs @${Time.Time24}
			/docommand /${cmdChannel} DoHideCorpses
			/delay 5s
			/docommand /${cmdChannel} DoHideLooted
 			/docommand /${cmdChannel} Doraidbuffs ALL
			/echo \awBuffs Requested, setting timer to 45m, and waiting 45s!
			/varset timer_allBuffs 45m
			:buffDelay
			/if (${int_buffDelay} < 45) {
				/delay 1s
				/varcalc int_buffDelay ${int_buffDelay}+1 
				/if (${SpawnCount[npc radius ${int_campRadius}]} > 0) /goto :return
				/goto :buffDelay
			}
		}
			
		/if (${bln_wait4Mana} || ${bln_wait4End} || ${bln_wait4HP}) {
			/echo Waiting for : mana: ${bln_wait4Mana} endurance: ${bln_wait4End} hitpoints: ${bln_wait4HP}
			/if (${SpawnCount[npc radius ${int_campRadius}]} > 0) /goto :return
			/if (!${Me.Sitting}) /sit on 
			/delay 50
			/goto :chkUtilLoop
		}
		:return
		/if (${Me.Sitting}) /sit off
/return


Sub chkMana
	/varset bln_wait4Mana FALSE
	/if ((${int_groupCLRidx} != -1) && (${Group.Member[${int_groupCLRidx}].PctMana} < ${int_clrManaFloor})) {
		/echo Cleric mana ${Group.Member[${int_groupCLRidx}].PctMana} < ${int_clrManaFloor}
		/varset bln_wait4Mana TRUE
	}
	/if ( (${int_groupENCidx} != -1) &&  (${Group.Member[${int_groupENCidx}].PctMana} < ${int_encManaFloor})) {
		/echo Enc mana ${Group.Member[${int_groupENCidx}].PctMana} < ${int_clrManaFloor}
		/varset bln_wait4Mana TRUE
	}
	
	/if (${strPullType.Equal[SPELL]} && (${Me.PctMana} <  ${int_myManaFloor})) {
		/echo  ${strPullType} My mana ${Me.PctMana} < ${int_clrManaFloor}
		/varset bln_wait4Mana TRUE
	}
	
	|-- I don't think you can check the mana of an out of group member without netbots, so ignore it
	|/if (${int_localENCidx} != -1) {
		|/target ID ${int_localENCidx}
		|/delay 10
		|/if (${Target.PctMana} < ${int_encManaFloor})
		|/varset bln_wait4Mana TRUE
	|}	
	
/return


Sub chkEndurance
	/varset bln_wait4End FALSE
	/if (${Me.PctEndurance} < ${int_myEnduranceFloor}) 	/varset bln_wait4End TRUE
/return

Sub chkHP
	/varset bln_wait4HP FALSE
	/if (${Me.PctHPs} < ${int_myHitpointFloor}) 	/varset bln_wait4HP TRUE
/return

Sub chkBuffs

	/echo ----
	/echo Checking Buffs
	/echo IDs    ENC:${int_groupENCidx} CLR: ${int_groupCLRidx} DRU: ${int_groupDRUidx} SHM:${int_groupSHMidx}
	/echo Timers ENC:${timer_buffENC} CLR: ${timer_buffCLR} DRU: ${timer_buffDRU} SHM:${timer_buffSHM}
	/echo ----
	/if (${SpawnCount[npc radius ${int_campRadius}]} > 0) /return
	
	/declare int_wait 		int 	local 0
	/declare hasBuffLine 	bool 	local FALSE
	/declare groupList		string  local
	/call 	 composeGroupList |
	/varset  groupList ${Macro.Return}
	
	|-- check to see if there is a cleric and I haven't bugged them for at least a minute
	/if ((${int_groupCLRidx} != -1) && (${timer_buffCLR} == 0)) {
		|-- if there is a druid, then we want SYMBOL, else, AEGO
		/if (${int_groupDRUidx} != -1) {
			|-- there is an available druid (highly unlikely) so lets ask for SYMBOL if I don't have it
			/call chkHasBuffLine SYMBOL ${Me.Name}
			/varset hasBuffLine ${Macro.Return}
			/if (!${hasBuffLine}) {
				/g Requesting SYMBOL from ${str_groupCLRname}
				/dt ${str_groupCLRname} requestBuffLine SYMBOL GROUP ${groupList}
				/varcalc int_wait ${int_wait} + 10
				/varset timer_buffCLR 10m
			}
		} else {
			|-- there isn't an available druid so lets ask for AEGO if I don't have it
			/call chkHasBuffLine AEGO ${Me.Name}
			/if (!${hasBuffLine}) {
				/g Requesting AEGO from ${str_groupCLRname}
				/dt ${str_groupCLRname} requestBuffLine AEGO GROUP ${groupList}
				/varcalc int_wait ${int_wait} + 10
				/varset timer_buffCLR 10m
			}
		}
	}
	
	
	|-- check to see if there is an echanter
	/if ((${int_groupENCidx} != -1) && (${timer_buffENC} == 0)) {
		|-- Check for Haste
		/call chkHasBuffLine ENC_HASTE ${Me.Name}
		/varset hasBuffLine ${Macro.Return}
		/if (!${hasBuffLine}) {
			/g Requesting ENC_HASTE from ${str_groupENCname}
			/dt ${str_groupENCname} requestBuffLine ENC_HASTE GROUP ${groupList}
			/varcalc int_wait ${int_wait} + 10
			/varset timer_buffENC 10m
		}
		|-- Check for Crack
		/call chkHasBuffLine CRACK ${Me.Name}
		/varset hasBuffLine ${Macro.Return}
		/if (!${hasBuffLine}) {
			/g Requesting CRACK from ${str_groupENCname}
			/dt ${str_groupENCname} requestBuffLine CRACK GROUP ${groupList}
			/varcalc int_wait ${int_wait} + 10
			/varset timer_buffENC 10m
		}
	}
	
	|-- check to see if there is a druid
	/if ((${int_groupDRUidx} != -1) && (${timer_buffDRU} == 0)) {
		|-- Check for NINE
		/call chkHasBuffLine NINE ${Me.Name}
		/varset hasBuffLine ${Macro.Return}
		/if (!${hasBuffLine}) {
			/g Requesting NINE from ${str_groupDRUname}
			/dt ${str_groupDRUname} requestBuffLine NINE GROUP ${groupList}
			/varset int_wait ${int_wait} + 10
			/varset timer_buffDRU 10m
		}
		|-- Check for DS
		/call chkHasBuffLine DRU_DS ${Me.Name}
		/varset hasBuffLine ${Macro.Return}
		/if (!${hasBuffLine}) {
			/g Requesting DRU_DS from ${str_groupDRUname}
			/dt ${str_groupDRUname} requestBuffLine DRU_DS GROUP ${groupList}
			/varset int_wait ${int_wait} + 10
			/varset timer_buffDRU 10m
		}
	}
	
		|-- check to see if there is a cleric and I haven't bugged them for at least a minute
	/if ((${int_groupSHMidx} != -1) && (${timer_buffSHM} == 0)) {
		|-- if there is a druid, then we can skip haste, else, SHM_HASTE
		/if (${int_groupENCidx} != -1) {
			/call chkHasBuffLine SHM_HASTE ${Me.Name}
			/varset hasBuffLine ${Macro.Return}
			/if (!${hasBuffLine}) {
				/g Requesting SHM_HASTE from ${str_groupSHMname}
				/dt ${str_groupSHMname} requestBuffLine SHM_HASTE GROUP ${groupList}
				/varcalc int_wait ${int_wait} + 10
				/varset timer_buffSHM 10m
			}
		}
		|-- check for STR
		/call chkHasBuffLine FOCUS ${Me.Name}
		/varset hasBuffLine ${Macro.Return}
		/if (!${hasBuffLine}) {
			/g Requesting STR from ${str_groupSHMname}
			/dt ${str_groupSHMname} requestBuffLine STR GROUP ${groupList}
			/varcalc int_wait ${int_wait} + 10
			/varset timer_buffSHM 10m
		}
		|-- check for STA
		/call chkHasBuffLine STA ${Me.Name}
		/varset hasBuffLine ${Macro.Return}
		/if (!${hasBuffLine}) {
			/g Requesting STA from ${str_groupSHMname}
			/dt ${str_groupSHMname} requestBuffLine STA GROUP ${groupList}
			/varcalc int_wait ${int_wait} + 10
			/varset timer_buffSHM 10m
		}
		|-- check for AGI
		/call chkHasBuffLine AGI ${Me.Name}
		/varset hasBuffLine ${Macro.Return}
		/if (!${hasBuffLine}) {
			/g Requesting AGI from ${str_groupSHMname}
			/dt ${str_groupSHMname} requestBuffLine AGI GROUP ${groupList}
			/varcalc int_wait ${int_wait} + 10
			/varset timer_buffSHM 10m
		}
	}
	
	
	/echo Waiting ${int_wait}s for buffs
	/delay ${int_wait}s
	

	
/return


|**
 ----------------------------
 setSupportIDs
 ----------------------------
 Here we set the id of the group's cleric and other support classes.
 If we are in a raid setup, we handle that too as a 'local ID' instead of 'group ID'
 ----------------------------
**|
sub setSupportIDs
	/if (${useGroup}) {
		/declare gmember int local 0
		/for gmember 0 to ${Group}
			|-- Cleric
			/if (${Group.Member[${gmember}].Class.ShortName.Equal[CLR]}) {
				/echo Setting int_groupSHMidx to ${gmember}
				/varset int_groupCLRidx ${gmember}
				/varset str_groupCLRname ${Group.Member[${gmember}].Name}
			} else /if (${Group.Member[${gmember}].Class.ShortName.Equal[ENC]}) {
				/echo Setting int_groupENCidx to ${gmember}
				/varset int_groupENCidx ${gmember}
				/varset str_groupENCname ${Group.Member[${gmember}].Name}
			} else /if (${Group.Member[${gmember}].Class.ShortName.Equal[DRU]}) {
				/echo Setting int_groupDRUidx to ${gmember}
				/varset int_groupDRUidx  ${gmember}
				/varset str_groupDRUname ${Group.Member[${gmember}].Name}
			} else /if (${Group.Member[${gmember}].Class.ShortName.Equal[SHM]}) {
				/echo Setting int_groupSHMidx to ${gmember}
				/varset int_groupSHMidx ${gmember}
				/varset str_groupSHMname ${Group.Member[${gmember}].Name}
			}
		/next gmember
		
		|-- Friendly warning
		/if (${int_groupCLRidx} == -1) {
			/beep
			/echo !! WARNING !! No Cleric Found, you are brave!
		}
	} else {
		|-- Raid looping not implemented yet because I am lazy
	}

/return 




Sub chkComponents
	/if (${SpawnCount[npc radius ${int_campRadius}]} > 0) /return
	/if (${FindItemCount[=${item_pull_clean}]}>=50) /return
	/if (${strPullType.Equal[SPELL]}) /return

	/echo Pull Component: ${item_pull_clean} Count:${FindItemCount[=${item_pull_clean}]}
	
	:chkComponent
	/autoinv
	/if (${SpawnCount[npc radius ${int_campRadius}]} > 0) /return
	
	/if (${FindItemCount[=${item_pull_clean}]}>=200) /return
	
	/if (${FindItemCount[=${item_summon}]}>0) {
	/echo ${FindItemCount[=${item_summon}]}
		/echo ${item_summon} summoning ${item_pull_clean}
		:summon_item
		/call MQ2Cast "${item_summon}"
		/delay 50
		/autoinv
		/goto :chkComponent
	}
	
/return	
		


|**
 ----------------------------
 Initialization
 ----------------------------
 Here we declare variables
 Eventually this needs to be pulled from an INI per zone and per puller!
 ----------------------------
**|
Sub variant_initialize(int _pull_dist, string _channel, string _campName, bool _useDownFlags, bool _usePull)
	/echo \awvariant_initialize \ao ${_pull_dist} ${_channel} ${_campName} ${_useDownFlags} ${_usePull}

	|--loot
	/varset bln_looting				FALSE
	/if (${bln_looting}) 			/call EnableLooting
	/if (!${_usePull})				/call EnableLooting

	|--downflags 
	/declare useDownFlags	bool	outer	TRUE
	/if (${Defined[_useDownFlags]} && !${_useDownFlags}) /varset useDownFlags FALSE

	|--are we pulling or are we just running around killing?
	/declare bln_usePull			bool	outer	TRUE
	/if (${Defined[_usePull]}) {
		/varset bln_usePull ${_usePull}
	}
	
	|--melee plugin/aggro for the requester
	/melee aggro=1
	/speed 1.5
	/declare useGroup	bool	outer	FALSE
	
	|--command channel setup
	/if (!${Defined[cmdChannel]}) /declare cmdChannel string	outer	dga
	/varset cmdChannel dga
	/if (${Defined[_channel]}) /varset cmdChannel ${_channel}
	/echo 	cmdChannel is ${cmdChannel}

	|--camp counts
	/declare int_currentCamp		int		outer	1
	/declare int_campCount			int 	outer	1
	/declare str_campName           string  outer   camp1
	/declare bln_increment 			bool	outer	TRUE
	/if (${Defined[_campName]}) {
		/varset str_campName ${_campName}
	}	

	|--set up the camp logic
	/if (!${Defined[int_campX]}) /declare int_campX 				int outer ${Me.X}
	/if (!${Defined[int_campY]}) /declare int_campY 				int outer ${Me.Y}
	/if (!${Defined[int_campZ]}) /declare int_campZ 				int outer ${Me.Z}

	/declare D1X int outer ${Me.X}
	/declare D1Y int outer ${Me.Y}
	/declare D1Z int outer ${Me.Z}

	|--set the camp spot
	/call setCamp

	|--radii
	/declare int_pcCount			int 	outer   ${SpawnCount[PC]}
	/if (!${Defined[int_campRadius]}) /declare int_campRadius			int		outer	85
	/varset int_campRadius 85
	/declare int_maxRadius			int		outer	550
	/if (${Defined[_pull_dist]}) {
		/varset int_maxRadius ${_pull_dist}
	}


	|--how far we can go for alert 2 mobs (note, seperate from maxRadius)
	/declare int_alert2Radius		int 	outer 	
	/varcalc int_alert2Radius		${int_maxRadius}+500

	|-- use 40 for POFire
	/declare int_minZHeight			int		outer 	0
	/declare int_maxZHeight			int		outer	0
	/declare int_zRadius			int     outer   0
	/varcalc int_minZHeight			${Me.Z} - 150
	/varcalc int_maxZHeight			${Me.Z} + 200
	/varcalc int_zRadius ${int_maxZHeight} - ${int_minZHeight}
	/declare int_closeEnoughRadius	int		outer   50

	|--target information
	/declare int_maxPullCount		int		outer   4
	/declare int_minTLevel			int		outer	8
	/declare int_maxTLevel			int		outer	75
	/declare bln_validTGT			bool	outer	FALSE
	/declare bln_TGTDead			bool	outer	FALSE
	/declare bln_TGTLocal			bool	outer	FALSE
	/declare int_distTGT			int		outer	0
	/declare int_distTGTPredict		int		outer	0
	/declare int_alertCount			int		outer	0
	/declare int_killCount			int		outer	0
	
	|--utility floors
	/declare int_myHitpointFloor	int		outer	60
	/declare int_myEnduranceFloor	int		outer	0
	|-- note my mana floor only matters if I am a spell casting puller
	/declare int_myManaFloor		int		outer	20 
	/declare int_clrManaFloor		int		outer	20
	/declare int_encManaFloor		int		outer	0
	/declare bln_wait4Mana			bool	outer	FALSE
	/declare bln_wait4HP			bool	outer	FALSE
	/declare bln_wait4End			bool	outer	FALSE
	
	|--spell & support definitions are declared in xiris_melee.inc
	/declare timer_taunt            timer 	outer    3s

	|--set the puller type 
	/declare strPullType	string	outer	RANGED
	
	| MELEE DPS CLASS ENUMERATION - Endurance Focus
	/if (${Select[${Me.Class.ShortName},ROG,BER,MNK]}) {
		/varset strPullType RANGED
	}
	
	| MELEE DPS CLASS ENUMERATION - Mana Focus
	/if (${Select[${Me.Class.ShortName},BST,RNG,BRD]}) {
		/varset strPullType RANGED
	}	
	
	| TANK CLASS ENUMERATION
	/if (${Select[${Me.Class.ShortName},WAR]}) {
		/varset strPullType RANGED
	}		
	
	| TANK CASTER CLASS ENUMERATION
	/if (${Select[${Me.Class.ShortName},SHD,PAL]}) {
		/varset strPullType SPELL
	}	
	
	| MANUAL SETTING VIA TOON NAME HERE
	/if (${Me.Name.Equal[Sadelia]}) /varset strPullType RANGED

	
	/declare int_obstacleCNT		int 	outer 	0
	/declare bln_noLOS				bool	outer	FALSE	
	/declare bln_tooClose			bool	outer	FALSE
	/declare timer_allBuffs         timer   outer   20m
	
	|--find the support members of the group for use in keeping up buffs
	/declare int_groupCLRidx int outer -1
	/declare int_localCLRid int outer -1
	/declare str_groupCLRname string outer NULL
	/declare timer_buffCLR timer	outer  1s

	/declare int_groupENCidx int outer -1
	/declare int_localENCid int outer -1
	/declare str_groupENCname string outer NULL
	/declare timer_buffENC timer	outer  1s
	
	/declare int_groupDRUidx int outer -1
	/declare int_localDRUid int outer -1
	/declare str_groupDRUname string outer NULL
	/declare timer_buffDRU timer	outer  1s

	/declare int_groupSHMidx int outer -1
	/declare int_localSHMid int outer -1
	/declare str_groupSHMname string outer NULL
	/declare timer_buffSHM timer	outer 1s
		
	
	/call setSupportIDs
	/call setAlerts
/return


Sub setAlerts
	/echo \aw Adding Alerts (1: ignore, 2:hunt)
	|=================================
	|--- specific zone mobs to avoid;
	|    06/12 ordered by zone for performance
	|=================================
	|-- Global Ignores
	/squelch /alert clear 1
	/squelch /alert add 1 "abadacadvra"
	/squelch /alert add 1 "Xeixa`"
	/squelch /alert add 1 "Xiexa`"
	/squelch /alert add 1 "Xeixi`"
	/squelch /alert add 1 "Shinxia`"
	/squelch /alert add 1 "Shynxia`"

	|-- LDON Ignores
	/squelch /alert add 1 "a bitten victim"
	/squelch /alert add 1 "a petrified colossal tree"
	/squelch /alert add 1 "a hollow tree"
	/squelch /alert add 1 "a trap"
	/squelch /alert add 1 "flavor text"
	/squelch /alert add 1 "ten"
	/squelch /alert add 1 "six"
	/squelch /alert add 1 "two"
	/squelch /alert add 1 "a hissing"
	/squelch /alert add 1 "four"
	/squelch /alert add 1 "eight"
	/squelch /alert add 1 "three"
	/squelch /alert add 1 "ten"
	/squelch /alert add 1 "TerrorSpawner"
	/squelch /alert add 1 "a shimmering orb"
	/squelch /alert add 1 "aedispellph"
	/squelch /alert add 1 "aerainph"
	/squelch /alert add 1 "from no where"
	/squelch /alert add 1 "mini named controller"
	/squelch /alert add 1 "the hair"
	/squelch /alert add 1 "a young dire wolf"

	|-- Zone Specific Ignores
	/if (${Zone.ShortName.Equal[dranik]}) {
		/squelch /alert add 1 "Filligno the Slayer"
	}
	/if (${Zone.ShortName.Equal[kodtaz]}) {
		/squelch /alert add 1 "Kenra"
		/squelch /alert add 1 "Gazak"
		/squelch /alert add 1 "Maroley"
	}
	/if (${Zone.ShortName.Equal[riwwi]}) {
		/squelch /alert add 1 "yunjo"
		/squelch /alert add 1 "Kayin"
		/squelch /alert add 1 "Turlini"
		/squelch /alert add 1 "Narundel"
		/squelch /alert add 1 "Namosa"
		/squelch /alert add 1 "Ranguali"
		/squelch /alert add 1 "Iniba"
		/squelch /alert add 1 "Uxnikk"
		/squelch /alert add 1 "Kekken"
	}
	/if (${Zone.ShortName.Equal[barindu]}) {
		/squelch /alert add 1 "yunjo"
		/squelch /alert add 1 "Chiaka"
		/squelch /alert add 1 "Diru"
		/squelch /alert add 1 "Abena"
		/squelch /alert add 1 "Amari"
		/squelch /alert add 1 "Scribe"
		/squelch /alert add 1 "Gurru"
		/squelch /alert add 1 "Udranda"
		/squelch /alert add 1 "Aneuk Controller"
	}  
	/if (${Zone.ShortName.Equal[ferubi]}) {
		/squelch /alert add 1 "Rondo"
	}  
	/if (${Zone.ShortName.Equal[qinimi]}) {
		/squelch /alert add 1 "Krvne"
		/squelch /alert add 1 "Mass of Stone"
		/squelch /alert add 1 "Councilman"
		/squelch /alert add 1 "a broken"
		/squelch /alert add 1 "Rarundel"
		/squelch /alert add 1 "a disgruntled" 
		/squelch /alert add 1 "a melancholy"
		/squelch /alert add 1 "Besana"
	}  
	/if (${Zone.ShortName.Equal[pofire]}) {
		/squelch /alert add 1 "Guardian of Doomfire"
		/squelch /alert add 1 "General Reparm"
		/squelch /alert add 1 "General Druav Flamesinger"
		/squelch /alert add 1 "Blazzax the Omnifiend"
		/squelch /alert add 1 "All Powerful Gnome"
		/squelch /alert add 1 "Pyronis"
		/squelch /alert add 1 "Magmaton"
		/squelch /alert add 1 "Arch Mage Yozanni"
	}  
	/if (${Zone.ShortName.Equal[qvic]}) {
		/squelch /alert add 1 "Ptav M'sha"
		/squelch /alert add 1 "Dvoin M'sha"
		/squelch /alert add 1 "Mnat M'sha"
		/squelch /alert add 1 "Aganetti the Keeper"
		/squelch /alert add 1 "Cynosure Kvanjji"
		/squelch /alert add 1 "Qkav`d the Fourth Arbitor"
		/squelch /alert add 1 "Svi`pral the Second Arbitor"
		/squelch /alert add 1 "Vishai the First Arbitor"
		/squelch /alert add 1 "Ytvagi the Third Arbitor"
	}  
	/if (${Zone.ShortName.Equal[riftseekers]}) {
		/squelch /alert add 1 "a ferocious chimera"
		/squelch /alert add 1 "a ferocious feran"
		/squelch /alert add 1 "Chailak"
		/squelch /alert add 1 "Feratha"
		/squelch /alert add 1 "Prince Allin"
		/squelch /alert add 1 "Prince Britalic" 
		/squelch /alert add 1 "Prince Cynin"
		/squelch /alert add 1 "Prince Ilsin"
		/squelch /alert add 1 "Prince Kiranus"
		/squelch /alert add 1 "Prince Scyllus"
		/squelch /alert add 1 "Princess Kira"
		/squelch /alert add 1 "Princess Lana"
		/squelch /alert add 1 "Princess Puja"
		/squelch /alert add 1 "Princess Quellon"
		/squelch /alert add 1 "Princess Yelnia"
		/squelch /alert add 1 "Princess Zulaqua"
		/squelch /alert add 1 "King Gelaqua"
		/squelch /alert add 1 "Queen Pyrilonis"
		/squelch /alert add 1 "Taromani"
		/squelch /alert add 1 "portal"
	} 
	/if (${Zone.ShortName.Equal[wallofslaughter]}) {
		/squelch /alert add 1 "Korshawn"
		/squelch /alert add 1 "Jarekiv"
		/squelch /alert add 1 "a portal crystal"
		/squelch /alert add 1 "Girplan Guardian"
		/squelch /alert add 1 "Dragorn Champion"
		/squelch /alert add 1 "Trelak" 
		/squelch /alert add 1 "Verow"
		/squelch /alert add 1 "Sandak"
		/squelch /alert add 1 "Velitorkin"
 	}
	/if (${Zone.ShortName.Equal[ssratemple]}) {
		/squelch /alert add 1 "Rhag"
	}
	/if (${Zone.ShortName.Equal[chardok]}) {
		/squelch /alert add 1 "slave"
		/squelch /alert add 1 "niblek"
		/squelch /alert add 1 "vault master"
	}
	/if (${Zone.ShortName.Equal[burningwood]}) {
		/squelch /alert add 1 "a sarnak imitator"
	}
	/if (${Zone.ShortName.Equal[rathemtn]}) {
		/squelch /alert add 1 "Guzzla"
		/squelch /alert add 1 "Chizzlik"
		/squelch /alert add 1 "Ukla"
	}
	


	|=================================
	|--- specific zone mobs to hunt;
	|=================================
	/squelch /alert clear 2
	/squelch /alert add 2 "foobarbaza"

	/if (${Zone.ShortName.Equal[trakanon]}) {
		|--Hunter Cycle--|
		/squelch /alert add 2 "froglok hunter"
		/squelch /alert add 2 "Oracle Froskil"
		/squelch /alert add 2 "Harbinger Josk"
		/squelch /alert add 2 "Knight Dragol"
		/squelch /alert add 2 "Vessel Fryn"
		/squelch /alert add 2 "Keeper Sepsis"
		/squelch /alert add 2 "Ebon lotus"
		/squelch /alert add 2 "Ffroaak"
		/squelch /alert add 2 "Dreadlord Dekir"
		/squelch /alert add 2 "Partisan Yinlen"
		/squelch /alert add 2 "Doom"
		/squelch /alert add 2 "Throkkok"
		/squelch /alert add 2 "Hierophant Ixyl"
		/squelch /alert add 2 "Master Fasliw"
		/squelch /alert add 2 "Sigra"

		|-- Forager Cycle--|
		/squelch /alert add 2 "froglok forager"
		/squelch /alert add 2 "Champion Thenrin"
		/squelch /alert add 2 "Commander Sils"
		/squelch /alert add 2 "Titail Sinok"
		/squelch /alert add 2 "Bloodeye"
		/squelch /alert add 2 "Dreadlord Fanrik"
		/squelch /alert add 2 "Hangman"
		/squelch /alert add 2 "Dragontail"
		/squelch /alert add 2 "Squire Glik"
		/squelch /alert add 2 "Klok Denris"
		/squelch /alert add 2 "Crusader Zoglic"
		/squelch /alert add 2 "Harbinger Dronik"
		/squelch /alert add 2 "Keeper Lasnik"
		/squelch /alert add 2 "Silvermane"
		/squelch /alert add 2 "Thruke"
		/squelch /alert add 2 "Flayhte"
		/squelch /alert add 2 "Champion Arlek"
		/squelch /alert add 2 "froglok_hunter"
		/squelch /alert add 2 "Oracle Froskil"
		/squelch /alert add 2 "Harbinger Josk"
		/squelch /alert add 2 "Knight Dragol"
		/squelch /alert add 2 "Vessel Fryn"
		/squelch /alert add 2 "Keeper Sepsis"
		/squelch /alert add 2 "Ebon lotus"
		/squelch /alert add 2 "Ffroaak"
		/squelch /alert add 2 "Dreadlord Dekir"
		/squelch /alert add 2 "Partisan Yinlen"
		/squelch /alert add 2 "Doom"
		/squelch /alert add 2 "Throkkok"
		/squelch /alert add 2 "Hierophant Ixyl"
		/squelch /alert add 2 "Master Fasliw"
		/squelch /alert add 2 "Sigra"

	|-- Skin Samples--|	
	} else /if (${Zone.ShortName.Equal[qvic]} || ${Zone.ShortName.Equal[kodtaz]} || ${Zone.ShortName.Equal[txevu]}) {
		/squelch /alert add 2 "ikaav"
		/squelch /alert add 2 "ixt"
	|-- Anguish Signets--|
	} else /if (${Zone.ShortName.Equal[riftseekers]}) {
		/squelch /alert add 2 "Battlemaster"
	} else /if (${Zone.ShortName.Equal[draniksewersa]} || ${Zone.ShortName.Equal[draniksewersb]} || ${Zone.ShortName.Equal[draniksewersb]}) {
		/squelch /alert add 2 "Cunning"
	} else /if (${Zone.ShortName.Equal[dranikcatacombsa]} || ${Zone.ShortName.Equal[dranikcatacombsb]} || ${Zone.ShortName.Equal[dranikcatacombsc]}) {
		/squelch /alert add 2 "Insidious"
	} else /if (${Zone.ShortName.Equal[provinggrounds]}) {
		|/squelch /alert add 2 "Tactician"
		/squelch /alert add 2 "noc"
	} else /if (${Zone.ShortName.Equal[dranikhollowsa]} || ${Zone.ShortName.Equal[dranikhollowsb]} || ${Zone.ShortName.Equal[dranikhollowsc]} || ${Zone.ShortName.Equal[dranikhollowsd]} || ${Zone.ShortName.Equal[dranikhollowse]} || ${Zone.ShortName.Equal[dranikhollowsf]} || ${Zone.ShortName.Equal[dranikhollowsg]} || ${Zone.ShortName.Equal[dranikhollowsh]} || ${Zone.ShortName.Equal[dranikhollowsi]} || ${Zone.ShortName.Equal[dranikhollowsj]}) {
		/squelch /alert add 2 "Shrewd"
		| Note, this should be dranikhollowsa "Watering Hole"
	} else /if (${Zone.ShortName.Equal[dranik]}) {
		/squelch /alert add 2 "Prodigy"
	
	|--Breakdown in Communication
	} else /if (${Zone.ShortName.Equal[riwwi]}) {
		/squelch /alert add 2 "night watchman"
		/squelch /alert add 2 "officiator"
	} else /if (${Zone.ShortName.Equal[barindu]}) {
		/squelch /alert add 2 "aneuk"
	} else /if (${Zone.ShortName.Equal[qinimi]}) {
		/squelch /alert add 2 "Ticov"
		/squelch /alert add 2 "Rexi"
		/squelch /alert add 2 "Vket"
	

	|--Epic Stuff
	} else /if (${Zone.ShortName.Equal[povalor]}) {
		/squelch /alert add 2 "a valorian guard"
		/squelch /alert add 2 "a valorian guardsman"
		/squelch /alert add 2 "valorian watchman"
		/squelch /alert add 2 "sergeant"
		/squelch /alert add 2 "lieutenant"
		/squelch /alert add 2 "a squad leader"
	} else /if (${Zone.ShortName.Equal[poinnovation]}) {
		/squelch /alert add 2  "a degrading guardian"
		/squelch /alert add 2  "a weathered guardian"
		/squelch /alert add 2  "a weathered clockwork"
	} else /if (${Zone.ShortName.Equal[ssratemple]}) {
		/squelch /alert add 2 "Shissar Assassin"
	} else /if (${Zone.ShortName.Equal[chardok]}) {
		/squelch /alert add 2 "iksar betrayer"
	} else /if (${Zone.ShortName.Equal[southkarana]} || ${Zone.ShortName.Equal[rathemtn]}) {
		/if (${Me.Class.ShortName.Equal[BRD]}) {
			/varset int_minTLevel 8
			/squelch /alert add 2 "an obsidian drake"
			/squelch /alert add 2 "an ebon drake"
			/squelch /alert add 2 "an onyx drake"
			/squelch /alert add 2 "Blackwing"
		} else /if (${Me.Class.ShortName.Equal[MNK]}) {
			/squelch /alert add 2 "Brother Zephyl"
			/squelch /alert add 2 "Brother Qwinn"
		}
	} else /if (${Zone.ShortName.Equal[skyfire]}) {
		/squelch /alert add 2 "a skyash drake"
		/squelch /alert add 2 "Eldrig the Old"
		/squelch /alert add 2 "a mature wurm"
		/squelch /alert add 2 "a shadow drake"
		/squelch /alert add 2 "a lava walker"
		/squelch /alert add 2 "a soul devourer"
		/squelch /alert add 2 "Black Scar"
	} else /if (${Zone.ShortName.Equal[burningwood]}) {
		/squelch /alert add 2 "wurm"
		/squelch /alert add 2 "Nezekezena"
	} else /if (${Zone.ShortName.Equal[karnor]}) {
		/varset int_maxPullCount 20
		/varset int_closeEnoughRadius 30
		/squelch /alert add 2 "warlord"
		/squelch /alert add 2 "bodyguard"
		/squelch /alert add 2 "pawbuster"
	} else /if (${Zone.ShortName.Equal[causeway]}) {
		/varset int_maxPullCount 10
		/squelch /alert add 2 "battle-scarred"
		/squelch /alert add 2 "mountain"
		/squelch /alert add 2 "murkglider stalker"
	} else /if (${Zone.ShortName.Equal[wallofslaughter]}) {
		/varset int_maxPullCount 10
		/squelch /alert add 2 "enchainer"
		/squelch /alert add 2 "darkwarrior"
		/squelch /alert add 2 "ireknight"
		/squelch /alert add 2 "mastermind"
	} else /if (${Zone.ShortName.Equal[gukbottom]}) {
		/varset int_maxPullCount 20
		
	}

/return

Sub Event_TooClose
	/echo Event_TooClose
	/varset bln_tooClose TRUE
	/doevents flush TooClose
/return

Sub Event_NoLOS
	/echo Event_NoLOS
	/varset bln_noLOS TRUE
	/doevents flush NoLOS
/return

