#define INI_CHAR        xiris_settings_character/BOT_${Me.Class.ShortName}_${Me.CleanName}.ini
#define INI_COMMON      xiris_settings_global/xiris_settings_common.ini
#include                xiris_includes/xiris_spell_routines.inc
#include                xiris_includes/xiris_buffing.inc


Sub Main 
    /declare int_MTID       int     outer   ${Me.ID}
    /declare bln_engaged    bool    outer   FALSE
    /declare str_currentSpellSet string outer default

    /declare arr_raidLeaders[9] string outer NULL

    | we might find this by looping through ${Raid.Member[${i}].GroupLeader} where i is 1-> ${Raid.Members} 
    | determining if if GroupLeader is true, and if so, add them to arr_raidLeaders
    /varset arr_raidLeaders[1] Xiris
    /varset arr_raidLeaders[2] Xiria
    /varset arr_raidLeaders[3] Xirea
    /varset arr_raidLeaders[4] Xirin
    /varset arr_raidLeaders[5] Xeqisa
    /varset arr_raidLeaders[6] Xaeliea
    /varset arr_raidLeaders[7] Xaexa
    /varset arr_raidLeaders[8] Xaia
    /varset arr_raidLeaders[9] Xepatia

    /call xbot_initialize_spellRoutines
    /call xbot_initialize_buffing
    /call xbot_initialize_curing

    :MainLoop
		/if (${Me.Hovering} || ${Window[tradewnd].Open} || ${Window[lootwnd].Open}) /goto :MainLoop

        | Always check cures, and set lazy to be TRUE when not engaged
        /if (!${timer_check_cures}) /call chkCures !${bln_engaged}

        | Check targetted buffs if they are set to automatic
        /if (${bln_targetedBuffs_automatic}) /call chkTargetedBuffs

        | Debug check the buffing events
        /call Events_Buffing

        | Debug check the curing events
        /call Events_Curing

        /if (${bln_engaged}) {
            /if (!${timer_check_combatBuffs}) /call chkCombatBuffs
            
        } else {
            | Check self buffs and clickies
            /if (!${timer_check_selfBuffs})     /call chkSelfBuffs

            | Check targetted buffs if they are set to automatic (only set up for self right now)
            /if (${bln_targetedBuffs_automatic} && !${timer_check_targetedBuffs}) /call chkTargetedBuffs SELF ${Me.Name} FALSE

            |/if (!${timer_check_utilities}) /call chkUtils
			|/if (!${timer_check_loot} && ${bln_looting}) /call chkLoot

        }
            
        /goto :MainLoop
/return 



|**
CURING V2
**|

#EVENT cureRequest		"#1# tells the group#*#'cureRequest #2#'"
#EVENT cureRequest		"#1# tells you#*#'cureRequest #2#'"
#EVENT cureRequest		"#1# tells the raid#*#'cureRequest #2#'"
#EVENT cureRequest  	"[ #1# #*#]#*#cureRequest #2#"

#EVENT cureGroup	    "#1# tells the group#*#'cureGroup #2#'"
#EVENT cureGroup        "#1# tells you#*#'cureGroup #2#'"
#EVENT cureGroup        "#1# tells the raid#*#'cureGroup #2#'"
#EVENT cureGroup        "[ #1# #*#]#*#cureGroup #2#"

#EVENT autoCure         "#1# tells the group#*#'autoCure #2#'"
#EVENT autoCure         "#1# tells you#*#'autoCure #2#'"
#EVENT autoCure         "#1# tells the raid#*#'autoCure #2#'"
#EVENT autoCure         "[ #1# #*#]#*#autoCure #2#"

Sub Events_Buffing
	/doevents cureRequest
	/doevents cureGroup

	/doevents autoCure
/return




Sub EVENT_cureRequest(string _line, string _sender,  string _eventParams)

/return

|**
 ----------------------------
 CURING Routines Initialization
 ----------------------------
 Will process the cure spells buffs defined in character INI
 Will process the debuffs defined in the global INI

 Sets default variables, and initializes the event listeners
 ----------------------------
**|

Sub xbot_initialize_curing

    /echo \agInitialize: \aoCuring \aw-------------------------
    | Pull these values from the INI_CHAR file
    /declare bln_autoCureMT     bool    outer   TRUE
    /declare bln_autoCureSelf   bool    outer   TRUE
    /declare bln_autoCureGroup  bool    outer   TRUE
    /declare bln_chkLazyCures   bool    outer   TRUE
    /declare timer_check_cures  timer   outer   0

    /declare int_immediateDebuffCures_total int outer 0
    /declare int_requiredDebuffCures_total  int outer 0

    /call processCureSettings
    /call processRequiredCures
    /call initEvents_curing
/return 

Sub initEvents_curing
    /if (${bln_hasCure_disease} || ${bln_hasCure_curse} || ${bln_hasCure_poison} || ${bln_hasCure_corruption}) /call RegisterBackgroundEvents Events_Buffing 3
/return

| This will be populated via INI file entriess
Sub processCureSettings
    /echo \awprocessCureSettings
    /declare bln_curing_enabled       bool outer  TRUE

    /declare bln_hasCure_radiant        bool    outer  FALSE
    /declare bln_useCure_radiant        bool    outer  FALSE
    /declare str_cure_radiant           string  outer "Radiant Cure"
    /declare str_cure_radiant_counters  string  outer 25

    /declare bln_hasCure_disease    bool outer  TRUE 
    /declare bln_hasCure_curse      bool outer  TRUE 
    /declare bln_hasCure_poison     bool outer  TRUE 
    /declare bln_hasCure_corruption bool outer  FALSE

    
    /declare str_cure_disease       string outer "Pure Blood"|TRUE|18
    /declare str_cure_curse         string outer "Remove Greater Curse"|TRUE|45
    /declare str_cure_poison        string outer "Antidote"|TRUE|64
    /declare str_cure_corruption    string outer "NULL"|TRUE|64


    /declare int_defaultCureGem     int  outer 7
    |; _enabled|_hasRadiant
	|  settings=TRUE
    /if (!${Ini[INI_CHAR,CURES,settings].Arg[1,|]})     /varset bln_curing_enabled    FALSE
    /echo \ao    Settings Processed: \awEnabled:\ag${bln_curing_enabled} 

    |; _radiant|_use|_type
    /if (${Ini[INI_CHAR,CURES,CURE_radiant].Arg[1,|]})  /varset bln_hasCure_radiant TRUE
    /if (${Ini[INI_CHAR,CURES,CURE_radiant].Arg[1,|]})  /varset str_cure_radiant    ${Ini[INI_CHAR,CURES,CURE_radiant].Arg[1,|]}  
    /if (${Ini[INI_CHAR,CURES,CURE_radiant].Arg[2,|]})  /varset bln_useCure_radiant TRUE  
    /if (${Ini[INI_CHAR,CURES,CURE_radiant].Arg[3,|]})  /varset bln_useCure_radiant ${Ini[INI_CHAR,CURES,CURE_radiant].Arg[3,|]}    

    /echo \ao    Settings Processed: \awEnabled:\ag${bln_targetedBuffs_enabled} \awAllowRaid:\ag${bln_targetedBuffs_allowRaid} \awAllowGroup:\ag${bln_targetedBuffs_allowGroup} \awAutomatic:\ag${bln_targetedBuffs_automatic}

/return 

| This will be populated by INI file entries
Sub processRequiredCures 
    /echo \awprocessRequiredCures
    | Debuffs that must be cured as soon as possible
    | [CURING_DEBUFF_IMMEDIATE]
    | ;_name|_cureType[disease||poison||curse||corruption]|_targets[ALL|MT|Class.ShortName CSV]
    /declare raw_immediateCures[20] string  local NULL
    /declare raw_requiredCures[20]  string  local NULL
    /declare i                      int     local 0
    /declare sz                     int     local 0 
    /declare test                   string  local NULL

    /for i 1 to ${raw_immediateCures.Size}
        | if the value of the entry ends with a quoted string, we need to wrap it all in quotes again.
        /varset test "${Ini[INI_COMMON,CURING_DEBUFF_IMMEDIATE,DEBUFF_${i}]}"
        /if (${test.Arg[1,|].Equal[NULL]}) {
            /varset int_immediateDebuffCures_total ${sz}
            /return
        }
        | Not null, set the values for the debuffs to be cured
        /varcalc sz ${sz}+1
        /declare DEBUFF_IMMEDIATE_${i}          string  outer   ${test.Arg[1,|]}
        /declare DEBUFF_IMMEDIATE_${i}_Type     string  outer   ${test.Arg[2,|]}
        /declare DEBUFF_IMMEDIATE_${i}_Targets  string  outer   ${test.Arg[3,|]}
        /echo \aoDebuff Processed[\ag${i}\ao]: \awDebuff:\ag${DEBUFF_IMMEDIATE_${i}} \awType:\ag${DEBUFF_IMMEDIATE_${i}_Type} \awTargets:\ag${DEBUFF_IMMEDIATE_${i}_Name}
    /next i

    /for i 1 to ${raw_requiredCures.Size}
        | if the value of the entry ends with a quoted string, we need to wrap it all in quotes again.
        /varset test "${Ini[INI_COMMON,CURING_DEBUFF_REQUIRED,DEBUFF_${i}]}"
        /if (${test.Arg[1,|].Equal[NULL]}) {
            /varset int_requiredDebuffCures_total ${sz}
            /return
        }
        | Not null, set the values for the debuffs to be cured
        /varcalc sz ${sz}+1
        /declare DEBUFF_REQUIRED_${i}          string   outer   ${test.Arg[1,|]}
        /declare DEBUFF_REQUIRED_${i}_Type     string   outer   ${test.Arg[2,|]}
        /declare DEBUFF_REQUIRED_${i}_Targets  string   outer   ${test.Arg[3,|]}
        /echo \aoDebuff Processed[\ag${i}\ao]: \awDebuff:\ag${DEBUFF_REQUIRED_${i}} \awType:\ag${DEBUFF_REQUIRED_${i}_Type} \awTargets:\ag${DEBUFF_REQUIRED_${i}_Name}
    /next i    

/return 

| Check Cures, we can bln_engaged as a good proxy for _lazy cures.
Sub chkCures(bool _lazy)
	/if (${bln_autoCureMT}) 	/call chkCure_MT    ${_lazy}
	/if (${bln_autoCureSelf}) 	/call chkCure_Self  ${_lazy}
	/if (${bln_autoCureGroup})  /call chkCure_Group ${_lazy}
/return

Sub chkCure_MT(bool _lazy)
    /call chkCureOnID ${int_MTID} ${_lazy}
/return 

Sub chkCure_Self(bool _lazy)
    /call chkCureOnID ${Me.ID} ${_lazy}
/return 

Sub chkCure_Group(bool _lazy, bool _forced, string _cureType)
    /call chkCureOnGroup ${_lazy} ${_forced} ${_cureType}
/return 

Sub chkCureOnGroup(bool _lazy, bool _forced, string _cureType)

/return


Sub chkCureOnID(int _id, bool _lazy)
    /if (${_lazy}) /varset timer_check_cures 50
    /echo \aochkCureOnId\aw(\ag${_id}\aw) Lazy? \ag${_lazy}
	| Check if MT needs cure
	| Specific items that need force cure
	/declare i 				int 	local	0
	/declare foundCounters	int		local	0
	/declare debuffName     string 	local NULL
    /declare debuffType     string  local NULL
    /declare victimName     string  local ${Spawn[pc id ${_id}].Name}

    | If no counters, return out
    /varset foundCounters 0
    /dquery ${victimName} -q "Debuff.Counters" -o foundCounters
    /delay 20 ${DanNet.Q.Received}
    /if (!${foundCounters}) /return

	| Immediate Cures  "Mark of Death"|disease|ALL
	:immediateCures
	/for i 1 to ${int_immediateDebuffCures_total}
		/varset foundCounters 0
        /echo \aoDebuffName \ag${DEBUFF_IMMEDIATE_${i}} \aoDebuffType \ag${DEBUFF_IMMEDIATE_${i}_Type}
		/dquery ${victimName} -q "Me.Buff[${DEBUFF_IMMEDIATE_${i}}.TotalCounters]" -o foundCounters
		/delay 20 ${DanNet.Q.Received}
		/if (${foundCounters}) {
			/call handleCureRequestV2 ${victimName} ${_id} ${DEBUFF_REQUIRED_${i}} ${DEBUFF_REQUIRED_${i}_Type} ${foundCounters} TRUE
            | If we cured something from immediate cures, we want to bail out of this to continue our checks on others
			/return
		}
		/if (${arr_immediateCures[${i}].Equal[NULL]}) /goto :requiredCures
	/next i


	| Required Cures
	:requiredCures
	/for i 1 to ${arr_requiredCures.Size}
		/varset foundCounters 0
		/varset debuffName ${arr_requiredCures[${i}].Arg[|,1]}
		/dquery ${victimName} -q "Me.Buff[${DEBUFF_REQUIRED_${i}}.TotalCounters]" -o foundCounters
		/delay 20 ${DanNet.Q.Received}
		/if (${foundCounters}) {
			/call handleCureRequestV2 ${victimName} ${_id} ${DEBUFF_REQUIRED_${i}} ${DEBUFF_REQUIRED_${i}_Type} ${foundCounters} TRUE
            | If we cured something from required cures, we want to bail out of this to continue our checks on others
			/return
		}
		/if (${arr_requiredCures[${i}].Equal[NULL]}) /goto :lazyCures
	/next i

    | Lazy cures: Out of Combat
	:lazyCures 
    /if (!${_lazy} || !${bln_chkLazyCures}) /return

    | Check Disease
    /varset foundCounters 0
    /dquery ${victimName} -q "Debuff.Diseased" -o foundCounters
    /if (${foundCounters}) {
        /call handleCureRequestV2 ${victimName} ${_id} ${arr_requiredCures[${i}]} ${foundCounters} FALSE
        /return
    }

    | Check Poison
    /varset foundCounters 0
    /dquery ${victimName} -q "Debuff.Poisoned" -o foundCounters
    /if (${foundCounters}) {
        /call handleCureRequestV2 ${victimName} ${_id} ${arr_requiredCures[${i}]} ${foundCounters} FALSE
        /return
    }

    | Check Curse
    /varset foundCounters 0
    /dquery ${victimName} -q "Debuff.Cursed" -o foundCounters
    /if (${foundCounters}) {
        /call handleCureRequestV2 ${victimName} ${_id} ${arr_requiredCures[${i}]} ${foundCounters} FALSE
        /return
    }
/return 


| note: curestring looks like "Wanton Destruction"|curse|ALL
| note: str_cure_curse looks like "Remove Greater Curse"|45 <= this is due to not being able to programmatically retrieve the amount of counters cured
Sub handleCureRequestV2(string _name, int _id, string _cureType, int _counters, bool _forced)
	/echo \ayhandleCureRequestV2: \ag${_name}\ao, \ag${_id}\ao, \ag${_cureString}\ao, \ag${_counters}\ao, \ag${_forced}
	| Verify I can actually cure this
	/if (!${bln_hasCure_${_cureString.Arg[2,|]}}) {
		/echo \ar Cannot cure ${_cureString.Arg[2,|]} due to lack of available cure.
        /return
	}

    | Debug information
    |/echo _cureString                                == "[debuff name]"|curse|ALL =>${_cureString}          
    |/echo _cureString.Arg[1,|]                       == "[debuff name]"=>${_cureString.Arg[1,|]}
    |/echo _cureString.Arg[2,|]                       == "[disease||poison||curse"]=>${_cureString.Arg[2,|]} 
    |/echo {str_cure_{_cureString.Arg[2,|]}}          == "Remove Greater Curse|45"=> ${str_cure_${_cureString.Arg[2,|]}}
    |/echo {str_cure_{_cureString.Arg[2,|]}.Arg[2,|]} == 45 =>${str_cure_${_cureString.Arg[2,|]}.Arg[2,|]}   

    | this string will look like "Remove Greater Curse"
	/declare cureSpell string local ${str_cure_${_cureString.Arg[2,|]}.Arg[1,|]}
	/if (!${SpawnCount[pc ${_name}]} || ${Spawn[pc ${_name}].Distance3D} > ${Spell[${cureSpell}].MyRange}) {
		/echo \arCannot cure ${_name} due to out of zone or out of range.
        /return
	}

	| Determine cast counts
	/declare countersToCure	int 	local ${_counters}
	/declare countersCured	int		local ${str_cure_${_cureString.Arg[2,|]}.Arg[2,|]}
	/declare castCount 		int 	local ${Math.Calc[${Math.Calc[${Math.Calc[${countersToCure}+${countersCured}]}-1]} / ${countersCured} ]}

    | Is the spell ready?
    /call chkSpellMemorized "${cureSpell}" TRUE ${int_defaultCureGem}
    | Cast the spell
    /call castCureV2 ${_name} ${_id} "${cureSpell}" ${castCount} ${_forced}
/return


Sub castCureV2(string _name, int _id, string _spell, int _castCount, bool _forced)
    /echo \ayCastCureV2: \ag${_name}\ao(\ag${_id}\ao) => \ag${_spell}\ao, \ag${_castCount}x\ao, \ag${_forced}
    /declare i int local 0
    /for i 1 to ${_castCount}
        /if (!${SpawnCount[pc ${_name}]}) /return
        /if (!${_forced} && (${int_healMode} > 0 && ${int_healMode} < 3) ) /call chkHeal_MT 
        /call TrueTarget ${_id}
        /call MQ2Cast "${_spell}" ${int_defaultCureGem} RunPriorityEvents
     /next i
/return 


|- Method will memorize a spell, to the optional attributed gem, and if wait is true, will wait until its ready to return
|- note will convert "gem7" to an integer 7 for gem slot
Sub chkSpellMemorized(string _spell, bool _wait, string _gem)
	/if (${_spell.Equal[NULL]}) {
       /docommand /${announceChannel} Ther was an error trying to memorize a NULL spell!;
       /return
    }
	/if (${Me.Gem[${_spell}]})  /return

    /declare int_gem int local ${int_defaultCureGem}
    /if (${_gem.NotEqual[NULL]}) {
         /if (${_gem.Length} > 1) {
            /varset int_gem ${_gem.Right[1]}
         }
    } else {
        /varset int_gem ${_gem}
    } 
   
	:mem
	    /echo \aochkSpellMemorized\ag "${_spell}" \awgem:\ao${int_gem} \awwait?:\ao${_wait}
		/memspell ${int_gem} "${_spell}" 
		/if (!${_wait}) /return

        /echo Waiting for ${_spell}
        /delay 50 ${Me.SpellReady[${_spell}]}
        /echo Spell Memorized
        /if (${Me.SpellReady[${_spell}]}) /return
        /docommand /${announceChannel} There was a timeout error trying to memorize "${_spell}"
/return 

Sub TrueTarget(int _targetID)
	/if (${SpawnCount[id ${_targetID}]} && ${Target.ID} != ${_targetID} ) {
		/declare retryTimer timer local 30
		:Target_Loop
		/squelch /target id ${_targetID}
		/delay 2 ${Target.ID} == ${_targetID}
		
		/if (${Target.ID} != ${_targetID} && ${SpawnCount[id ${_targetID}]}) {
			/if (${retryTimer}) {
				/goto :Target_Loop
			} else {
				/echo Failed to target [${Spawn[id ${_targetID}].CleanName} - ${_targetID}]
			}
		}
	}
/return
